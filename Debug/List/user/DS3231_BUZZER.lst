###############################################################################
#
# IAR ANSI C/C++ Compiler V9.30.1.335/W64 for ARM         29/Nov/2022  22:53:05
# Copyright 1999-2022 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =  C:\embedded\project\user\DS3231_BUZZER.c
#    Command line                 =
#        -f C:\embedded\project\Debug\Obj\user\DS3231_BUZZER.o.rsp
#        (C:\embedded\project\user\DS3231_BUZZER.c -D USE_STDPERIPH_DRIVER -D
#        STM32F10X_CL -lC C:\embedded\project\Debug\List\user -o
#        C:\embedded\project\Debug\Obj\user --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.1\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\embedded\project\Libraries\CMSIS\DeviceSupport\ -I
#        C:\embedded\project\Libraries\CMSIS\DeviceSupport\Startup\ -I
#        C:\embedded\project\Libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\ -I
#        C:\embedded\project\Libraries\STM32F10x_StdPeriph_Driver_v3.5\src\ -I
#        C:\embedded\project\Libraries\LCD\ -I C:\embedded\project\user\ -I
#        C:\embedded\project\user\inc\ -Ol -I "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.1\arm\CMSIS\Core\Include\\")
#        --dependencies=n C:\embedded\project\Debug\Obj\user\DS3231_BUZZER.o.d
#    Locale                       =  C
#    List file                    =
#        C:\embedded\project\Debug\List\user\DS3231_BUZZER.lst
#    Object file                  =
#        C:\embedded\project\Debug\Obj\user\DS3231_BUZZER.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#      __iar_require _Printf         
#      __size_limit               =  32768|ARM.EW.LINKER
#
###############################################################################

C:\embedded\project\user\DS3231_BUZZER.c
      1          #include <DS3231_BUZZER.h>
      2          

   \                                 In section .data, align 4
      3          int Alarm_flag = 1;
   \                     Alarm_flag:
   \        0x0   0x0000'0001        DC32 1

   \                                 In section .bss, align 4
      4          int Alarm_ONOFF = 0;
   \                     Alarm_ONOFF:
   \        0x0                      DS8 4
      5          
      6          // 진수 변환 함수
      7          /* USER CODE BEGIN PFP */

   \                                 In section .text, align 2, keep-with-next
      8          int decTobcd(uint8_t dec)
      9          {
   \                     decTobcd: (+1)
   \        0x0   0x0001             MOVS     R1,R0
     10          	return ((dec/10)*16)+(dec%10);
   \        0x2   0x000A             MOVS     R2,R1
   \        0x4   0xB2D2             UXTB     R2,R2
   \        0x6   0x200A             MOVS     R0,#+10
   \        0x8   0xB2C9             UXTB     R1,R1
   \        0xA   0x230A             MOVS     R3,#+10
   \        0xC   0xFB91 0xF1F3      SDIV     R1,R1,R3
   \       0x10   0xEB12 0x1101      ADDS     R1,R2,R1, LSL #+4
   \       0x14   0xFB92 0xF2F0      SDIV     R2,R2,R0
   \       0x18   0xFB00 0x1012      MLS      R0,R0,R2,R1
   \       0x1C   0x4770             BX       LR
     11          }

   \                                 In section .text, align 2, keep-with-next
     12          int bcdTodec(uint8_t bcd)
     13          {
     14          	return (bcd/16*10)+(bcd%16);
   \                     bcdTodec: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xB2C9             UXTB     R1,R1
   \        0x4   0x2210             MOVS     R2,#+16
   \        0x6   0xB2C0             UXTB     R0,R0
   \        0x8   0x0900             LSRS     R0,R0,#+4
   \        0xA   0xB2C0             UXTB     R0,R0
   \        0xC   0x230A             MOVS     R3,#+10
   \        0xE   0xFB03 0x1000      MLA      R0,R3,R0,R1
   \       0x12   0xFB91 0xF1F2      SDIV     R1,R1,R2
   \       0x16   0xFB02 0x0011      MLS      R0,R2,R1,R0
   \       0x1A   0x4770             BX       LR
     15          }
     16          

   \                                 In section .text, align 2, keep-with-next
     17          void I2C_Configure(void)
     18            {
   \                     I2C_Configure: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
     19                  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0x2008             MOVS     R0,#+8
   \        0x6   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     20                  RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
   \        0xA   0x2101             MOVS     R1,#+1
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     21                  RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE);
   \       0x12   0x2101             MOVS     R1,#+1
   \       0x14   0xF45F 0x1000      MOVS     R0,#+2097152
   \       0x18   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
     22                  
     23                  GPIO_InitTypeDef GPIO_InitStructure;
                                          ^
Warning[Pe177]: variable "GPIO_InitStructure" was declared but never referenced
     24                  
     25                  AFIO->MAPR = 0x00000002;
   \       0x1C   0x2002             MOVS     R0,#+2
   \       0x1E   0x.... 0x....      LDR.W    R1,??DataTable12_3
   \       0x22   0x6008             STR      R0,[R1, #+0]
     26                  GPIOB->CRH |= 0x000000FF;
   \       0x24   0x.... 0x....      LDR.W    R0,??DataTable12_4
   \       0x28   0x6801             LDR      R1,[R0, #+0]
   \       0x2A   0xF051 0x01FF      ORRS     R1,R1,#0xFF
   \       0x2E   0x6001             STR      R1,[R0, #+0]
     27                  
     28                  I2C_DeInit(I2C1);
   \       0x30   0x.... 0x....      LDR.W    R4,??DataTable12_5
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0x.... 0x....      BL       I2C_DeInit
     29                  
     30                  I2C1->CR1 = 0x0000;
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x8020             STRH     R0,[R4, #+0]
     31                  I2C1->CR2 = 0x0008;
   \       0x3E   0x2008             MOVS     R0,#+8
   \       0x40   0x.... 0x....      LDR.W    R1,??DataTable12_6
   \       0x44   0x8008             STRH     R0,[R1, #+0]
     32                  I2C1->CCR = 40;
   \       0x46   0x2028             MOVS     R0,#+40
   \       0x48   0x.... 0x....      LDR.W    R1,??DataTable12_7
   \       0x4C   0x8008             STRH     R0,[R1, #+0]
     33                  I2C1->TRISE = 0x0009;
   \       0x4E   0x2009             MOVS     R0,#+9
   \       0x50   0x.... 0x....      LDR.W    R1,??DataTable12_8
   \       0x54   0x8008             STRH     R0,[R1, #+0]
     34                  
     35                  I2C_Cmd(I2C1, DISABLE);
   \       0x56   0x2100             MOVS     R1,#+0
   \       0x58   0x0020             MOVS     R0,R4
   \       0x5A   0x.... 0x....      BL       I2C_Cmd
     36                  I2C_Cmd(I2C1, ENABLE);
   \       0x5E   0x2101             MOVS     R1,#+1
   \       0x60   0x0020             MOVS     R0,R4
   \       0x62   0x.... 0x....      BL       I2C_Cmd
     37          }
   \       0x66   0xBD10             POP      {R4,PC}
     38          

   \                                 In section .text, align 2, keep-with-next
     39          uint8_t HW_I2C_Read(I2C_TypeDef* I2Cx, uint8_t DeviceAddr, uint8_t RegisterAddr, uint16_t NumByteToRead, uint8_t* pBuffer)
     40          {
   \                     HW_I2C_Read: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x4699             MOV      R9,R3
     41            __IO uint32_t UTIL_Timeout = LONG_TIMEOUT;
   \        0xC   0xF44F 0x4620      MOV      R6,#+40960
   \       0x10   0x9600             STR      R6,[SP, #+0]
     42            __IO uint32_t temp;
     43          
     44            (void)(temp);
   \       0x12   0x9800             LDR      R0,[SP, #+0]
   \       0x14   0xE004             B.N      ??HW_I2C_Read_0
     45          
     46          restart:
     47          
     48            UTIL_Timeout = LONG_TIMEOUT;
     49          /* Send START condition */
     50            I2C_GenerateSTART(I2Cx, ENABLE);
     51            /* Test on EV5 and clear it */
     52            while (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_MODE_SELECT))
     53            {
     54              if (UTIL_Timeout-- == 0)
     55                return ERROR;
     56            }
     57          
     58            UTIL_Timeout = LONG_TIMEOUT;
     59            /* Send slave address for read */
     60            I2C_Send7bitAddress(I2Cx, DeviceAddr, I2C_Direction_Transmitter);
     61          
     62            while (!I2C_CheckEvent(I2Cx,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
     63            {
     64              if (UTIL_Timeout-- == 0)
     65              {
     66                I2C_ClearFlag(I2Cx,I2C_FLAG_BUSY|I2C_FLAG_AF);
   \                     ??HW_I2C_Read_1: (+1)
   \       0x16   0x.... 0x....      LDR.W    R1,??DataTable12_9
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0x.... 0x....      BL       I2C_ClearFlag
     67                goto restart;
     68              }
   \                     ??HW_I2C_Read_0: (+1)
   \       0x20   0x9600             STR      R6,[SP, #+0]
   \       0x22   0x2101             MOVS     R1,#+1
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0x.... 0x....      BL       I2C_GenerateSTART
   \                     ??HW_I2C_Read_2: (+1)
   \       0x2A   0x.... 0x....      LDR.W    R7,??DataTable12_10
   \       0x2E   0x0039             MOVS     R1,R7
   \       0x30   0x0020             MOVS     R0,R4
   \       0x32   0x.... 0x....      BL       I2C_CheckEvent
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD106             BNE.N    ??HW_I2C_Read_3
   \       0x3A   0x9800             LDR      R0,[SP, #+0]
   \       0x3C   0x1E41             SUBS     R1,R0,#+1
   \       0x3E   0x9100             STR      R1,[SP, #+0]
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD1F2             BNE.N    ??HW_I2C_Read_2
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0xE12F             B.N      ??HW_I2C_Read_4
   \                     ??HW_I2C_Read_3: (+1)
   \       0x48   0x9600             STR      R6,[SP, #+0]
   \       0x4A   0x2200             MOVS     R2,#+0
   \       0x4C   0x0029             MOVS     R1,R5
   \       0x4E   0xB2C9             UXTB     R1,R1
   \       0x50   0x0020             MOVS     R0,R4
   \       0x52   0x.... 0x....      BL       I2C_Send7bitAddress
   \                     ??HW_I2C_Read_5: (+1)
   \       0x56   0x.... 0x....      LDR.W    R1,??DataTable12_11
   \       0x5A   0x0020             MOVS     R0,R4
   \       0x5C   0x.... 0x....      BL       I2C_CheckEvent
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD105             BNE.N    ??HW_I2C_Read_6
   \                     ??HW_I2C_Read_7: (+1)
   \       0x64   0x9800             LDR      R0,[SP, #+0]
   \       0x66   0x1E41             SUBS     R1,R0,#+1
   \       0x68   0x9100             STR      R1,[SP, #+0]
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD1F3             BNE.N    ??HW_I2C_Read_5
   \       0x6E   0xE7D2             B.N      ??HW_I2C_Read_1
     69            }
     70            /* Clear EV6 by setting again the PE bit */
     71            I2C_Cmd(I2Cx, ENABLE);
   \                     ??HW_I2C_Read_6: (+1)
   \       0x70   0x2101             MOVS     R1,#+1
   \       0x72   0x0020             MOVS     R0,R4
   \       0x74   0x.... 0x....      BL       I2C_Cmd
     72          
     73            I2C_SendData(I2Cx, RegisterAddr);
   \       0x78   0x4641             MOV      R1,R8
   \       0x7A   0xB2C9             UXTB     R1,R1
   \       0x7C   0x0020             MOVS     R0,R4
   \       0x7E   0x.... 0x....      BL       I2C_SendData
     74          
     75            /* Test on EV8 and clear it */
     76            UTIL_Timeout = LONG_TIMEOUT;
   \       0x82   0x9600             STR      R6,[SP, #+0]
     77            while (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
   \                     ??HW_I2C_Read_8: (+1)
   \       0x84   0x.... 0x....      LDR.W    R1,??DataTable12_12
   \       0x88   0x0020             MOVS     R0,R4
   \       0x8A   0x.... 0x....      BL       I2C_CheckEvent
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xD106             BNE.N    ??HW_I2C_Read_9
     78            {
     79              if (UTIL_Timeout-- == 0)
   \       0x92   0x9800             LDR      R0,[SP, #+0]
   \       0x94   0x1E41             SUBS     R1,R0,#+1
   \       0x96   0x9100             STR      R1,[SP, #+0]
   \       0x98   0x2800             CMP      R0,#+0
   \       0x9A   0xD1F3             BNE.N    ??HW_I2C_Read_8
     80               return ERROR;
   \       0x9C   0x2000             MOVS     R0,#+0
   \       0x9E   0xE103             B.N      ??HW_I2C_Read_4
     81            }
   \                     ??HW_I2C_Read_9: (+1)
   \       0xA0   0xF8DD 0x8020      LDR      R8,[SP, #+32]
     82          
     83            if (NumByteToRead == 0x01)
   \       0xA4   0x4648             MOV      R0,R9
   \       0xA6   0xB280             UXTH     R0,R0
   \       0xA8   0x2801             CMP      R0,#+1
   \       0xAA   0xD00F             BEQ.N    ??HW_I2C_Read_10
     84            {
     85              restart3:
     86              /* Send START condition */
     87              I2C_GenerateSTART(I2Cx, ENABLE);
     88              while (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_MODE_SELECT));
     89              /* Send Slave address for read */
     90              I2C_Send7bitAddress(I2Cx, DeviceAddr, I2C_Direction_Receiver);
     91              /* Wait until ADDR is set */
     92              UTIL_Timeout = LONG_TIMEOUT;
     93              while (!I2C_GetFlagStatus(I2Cx, I2C_FLAG_ADDR))
     94              {
     95                if (UTIL_Timeout-- == 0)
     96                {
     97                  I2C_ClearFlag(I2Cx,I2C_FLAG_BUSY|I2C_FLAG_AF);
     98                  goto restart3;
     99                }
    100              }
    101              /* Clear ACK */
    102              I2C_AcknowledgeConfig(I2Cx, DISABLE);
    103              __disable_irq();
    104              /* Clear ADDR flag */
    105              temp = I2Cx->SR2;
    106              /* Program the STOP */
    107              I2C_GenerateSTOP(I2Cx, ENABLE);
    108              __enable_irq();
    109              while ((I2C_GetLastEvent(I2Cx) & 0x0040) != 0x000040); /* Poll on RxNE */
    110              /* Read the data */
    111              *pBuffer = I2C_ReceiveData(I2Cx);
    112              /* Make sure that the STOP bit is cleared by Hardware before CR1 write access */
    113              while ((I2Cx->CR1&0x200) == 0x200);
    114              /* Enable Acknowledgement to be ready for another reception */
    115              I2C_AcknowledgeConfig(I2Cx, ENABLE);
    116          
    117              return SUCCESS;
    118            }
    119            else
    120              if(NumByteToRead == 0x02)
   \       0xAC   0x4648             MOV      R0,R9
   \       0xAE   0xB280             UXTH     R0,R0
   \       0xB0   0x2802             CMP      R0,#+2
   \       0xB2   0xF040 0x808B      BNE.W    ??HW_I2C_Read_11
   \       0xB6   0xE04A             B.N      ??HW_I2C_Read_12
   \                     ??HW_I2C_Read_13: (+1)
   \       0xB8   0x9800             LDR      R0,[SP, #+0]
   \       0xBA   0x1E41             SUBS     R1,R0,#+1
   \       0xBC   0x9100             STR      R1,[SP, #+0]
   \       0xBE   0x2800             CMP      R0,#+0
   \       0xC0   0xD115             BNE.N    ??HW_I2C_Read_14
   \       0xC2   0x.... 0x....      LDR.W    R1,??DataTable12_9
   \       0xC6   0x0020             MOVS     R0,R4
   \       0xC8   0x.... 0x....      BL       I2C_ClearFlag
   \                     ??HW_I2C_Read_10: (+1)
   \       0xCC   0x2101             MOVS     R1,#+1
   \       0xCE   0x0020             MOVS     R0,R4
   \       0xD0   0x.... 0x....      BL       I2C_GenerateSTART
   \                     ??HW_I2C_Read_15: (+1)
   \       0xD4   0x0039             MOVS     R1,R7
   \       0xD6   0x0020             MOVS     R0,R4
   \       0xD8   0x.... 0x....      BL       I2C_CheckEvent
   \       0xDC   0x2800             CMP      R0,#+0
   \       0xDE   0xD0F9             BEQ.N    ??HW_I2C_Read_15
   \       0xE0   0x2201             MOVS     R2,#+1
   \       0xE2   0x0029             MOVS     R1,R5
   \       0xE4   0xB2C9             UXTB     R1,R1
   \       0xE6   0x0020             MOVS     R0,R4
   \       0xE8   0x.... 0x....      BL       I2C_Send7bitAddress
   \       0xEC   0x9600             STR      R6,[SP, #+0]
   \                     ??HW_I2C_Read_14: (+1)
   \       0xEE   0x.... 0x....      LDR.W    R1,??DataTable12_13
   \       0xF2   0x0020             MOVS     R0,R4
   \       0xF4   0x.... 0x....      BL       I2C_GetFlagStatus
   \       0xF8   0x2800             CMP      R0,#+0
   \       0xFA   0xD0DD             BEQ.N    ??HW_I2C_Read_13
   \       0xFC   0x2100             MOVS     R1,#+0
   \       0xFE   0x0020             MOVS     R0,R4
   \      0x100   0x.... 0x....      BL       I2C_AcknowledgeConfig
   \      0x104   0xB672             CPSID    I
   \      0x106   0x8B20             LDRH     R0,[R4, #+24]
   \      0x108   0x9000             STR      R0,[SP, #+0]
   \      0x10A   0x2101             MOVS     R1,#+1
   \      0x10C   0x0020             MOVS     R0,R4
   \      0x10E   0x.... 0x....      BL       I2C_GenerateSTOP
   \      0x112   0xB662             CPSIE    I
   \                     ??HW_I2C_Read_16: (+1)
   \      0x114   0x0020             MOVS     R0,R4
   \      0x116   0x.... 0x....      BL       I2C_GetLastEvent
   \      0x11A   0x0640             LSLS     R0,R0,#+25
   \      0x11C   0xD5FA             BPL.N    ??HW_I2C_Read_16
   \      0x11E   0x0020             MOVS     R0,R4
   \      0x120   0x.... 0x....      BL       I2C_ReceiveData
   \      0x124   0xF888 0x0000      STRB     R0,[R8, #+0]
   \                     ??HW_I2C_Read_17: (+1)
   \      0x128   0x8820             LDRH     R0,[R4, #+0]
   \      0x12A   0x0580             LSLS     R0,R0,#+22
   \      0x12C   0xD4FC             BMI.N    ??HW_I2C_Read_17
   \      0x12E   0x2101             MOVS     R1,#+1
   \      0x130   0x0020             MOVS     R0,R4
   \      0x132   0x.... 0x....      BL       I2C_AcknowledgeConfig
   \      0x136   0x2001             MOVS     R0,#+1
   \      0x138   0xE0B6             B.N      ??HW_I2C_Read_4
    121              {
    122                restart4:
    123                /* Send START condition */
    124                I2C_GenerateSTART(I2Cx, ENABLE);
    125                while (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_MODE_SELECT));
    126                /* Send EEPROM address for read */
    127                I2C_Send7bitAddress(I2Cx, DeviceAddr, I2C_Direction_Receiver);
    128                I2Cx->CR1 = 0xC01; /* ACK=1; POS =1 */
    129                UTIL_Timeout = LONG_TIMEOUT;
    130                while (!I2C_GetFlagStatus(I2Cx, I2C_FLAG_ADDR))
    131                {
    132                  if (UTIL_Timeout-- == 0)
   \                     ??HW_I2C_Read_18: (+1)
   \      0x13A   0x9800             LDR      R0,[SP, #+0]
   \      0x13C   0x1E41             SUBS     R1,R0,#+1
   \      0x13E   0x9100             STR      R1,[SP, #+0]
   \      0x140   0x2800             CMP      R0,#+0
   \      0x142   0xD118             BNE.N    ??HW_I2C_Read_19
    133                  {
    134                    I2C_ClearFlag(I2Cx,I2C_FLAG_BUSY|I2C_FLAG_AF);
   \      0x144   0x.... 0x....      LDR.W    R1,??DataTable12_9
   \      0x148   0x0020             MOVS     R0,R4
   \      0x14A   0x.... 0x....      BL       I2C_ClearFlag
    135                    goto restart4;
    136                  }
    137                }
   \                     ??HW_I2C_Read_12: (+1)
   \      0x14E   0x2101             MOVS     R1,#+1
   \      0x150   0x0020             MOVS     R0,R4
   \      0x152   0x.... 0x....      BL       I2C_GenerateSTART
   \                     ??HW_I2C_Read_20: (+1)
   \      0x156   0x0039             MOVS     R1,R7
   \      0x158   0x0020             MOVS     R0,R4
   \      0x15A   0x.... 0x....      BL       I2C_CheckEvent
   \      0x15E   0x2800             CMP      R0,#+0
   \      0x160   0xD0F9             BEQ.N    ??HW_I2C_Read_20
   \      0x162   0x2201             MOVS     R2,#+1
   \      0x164   0x0029             MOVS     R1,R5
   \      0x166   0xB2C9             UXTB     R1,R1
   \      0x168   0x0020             MOVS     R0,R4
   \      0x16A   0x.... 0x....      BL       I2C_Send7bitAddress
   \      0x16E   0xF640 0x4001      MOVW     R0,#+3073
   \      0x172   0x8020             STRH     R0,[R4, #+0]
   \      0x174   0x9600             STR      R6,[SP, #+0]
   \                     ??HW_I2C_Read_19: (+1)
   \      0x176   0x.... 0x....      LDR.W    R1,??DataTable12_13
   \      0x17A   0x0020             MOVS     R0,R4
   \      0x17C   0x.... 0x....      BL       I2C_GetFlagStatus
   \      0x180   0x2800             CMP      R0,#+0
   \      0x182   0xD0DA             BEQ.N    ??HW_I2C_Read_18
    138                __disable_irq();
   \      0x184   0xB672             CPSID    I
    139                /* Clear ADDR */
    140                temp = I2Cx->SR2;
   \      0x186   0x8B20             LDRH     R0,[R4, #+24]
   \      0x188   0x9000             STR      R0,[SP, #+0]
    141                /* Disable ACK */
    142                I2C_AcknowledgeConfig(I2Cx, DISABLE);
   \      0x18A   0x2100             MOVS     R1,#+0
   \      0x18C   0x0020             MOVS     R0,R4
   \      0x18E   0x.... 0x....      BL       I2C_AcknowledgeConfig
    143                __enable_irq();
   \      0x192   0xB662             CPSIE    I
    144                while ((I2C_GetLastEvent(I2Cx) & 0x0004) != 0x00004); /* Poll on BTF */
   \                     ??HW_I2C_Read_21: (+1)
   \      0x194   0x0020             MOVS     R0,R4
   \      0x196   0x.... 0x....      BL       I2C_GetLastEvent
   \      0x19A   0x0740             LSLS     R0,R0,#+29
   \      0x19C   0xD5FA             BPL.N    ??HW_I2C_Read_21
    145          
    146                 __disable_irq();
   \      0x19E   0xB672             CPSID    I
    147                /* Program the STOP */
    148                I2C_GenerateSTOP(I2Cx, ENABLE);
   \      0x1A0   0x2101             MOVS     R1,#+1
   \      0x1A2   0x0020             MOVS     R0,R4
   \      0x1A4   0x.... 0x....      BL       I2C_GenerateSTOP
    149                /* Read first data */
    150                *pBuffer = I2Cx->DR;
   \      0x1A8   0x8A20             LDRH     R0,[R4, #+16]
   \      0x1AA   0xF888 0x0000      STRB     R0,[R8, #+0]
    151                pBuffer++;
   \      0x1AE   0xF118 0x0001      ADDS     R0,R8,#+1
    152                /* Read second data */
    153                *pBuffer = I2Cx->DR;
   \      0x1B2   0x8A21             LDRH     R1,[R4, #+16]
   \      0x1B4   0x7001             STRB     R1,[R0, #+0]
    154                __enable_irq();
   \      0x1B6   0xB662             CPSIE    I
    155                I2Cx->CR1 = 0x0401; /* POS = 0, ACK = 1, PE = 1 */
   \      0x1B8   0xF240 0x4001      MOVW     R0,#+1025
   \      0x1BC   0x8020             STRH     R0,[R4, #+0]
    156          
    157                return SUCCESS;
   \      0x1BE   0x2001             MOVS     R0,#+1
   \      0x1C0   0xE072             B.N      ??HW_I2C_Read_4
    158              }
    159            else
    160            {
    161          restart2:
    162              UTIL_Timeout = LONG_TIMEOUT;
    163              /* Send START condition */
    164              I2C_GenerateSTART(I2Cx, ENABLE);
    165              /* Test on EV5 and clear it */
    166              while (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_MODE_SELECT))
    167              {
    168                if (UTIL_Timeout-- == 0) return ERROR;
    169              }
    170              UTIL_Timeout = LONG_TIMEOUT;
    171              /* Send slave address for read */
    172              I2C_Send7bitAddress(I2Cx,  DeviceAddr, I2C_Direction_Receiver);
    173              while (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))
    174              {
    175          
    176                if (UTIL_Timeout-- == 0)
    177                {
    178                  I2C_ClearFlag(I2Cx,I2C_FLAG_BUSY|I2C_FLAG_AF);
   \                     ??HW_I2C_Read_22: (+1)
   \      0x1C2   0x.... 0x....      LDR.W    R1,??DataTable12_9
   \      0x1C6   0x0020             MOVS     R0,R4
   \      0x1C8   0x.... 0x....      BL       I2C_ClearFlag
    179                  goto restart2;
    180                }
   \                     ??HW_I2C_Read_11: (+1)
   \      0x1CC   0x9600             STR      R6,[SP, #+0]
   \      0x1CE   0x2101             MOVS     R1,#+1
   \      0x1D0   0x0020             MOVS     R0,R4
   \      0x1D2   0x.... 0x....      BL       I2C_GenerateSTART
   \                     ??HW_I2C_Read_23: (+1)
   \      0x1D6   0x0039             MOVS     R1,R7
   \      0x1D8   0x0020             MOVS     R0,R4
   \      0x1DA   0x.... 0x....      BL       I2C_CheckEvent
   \      0x1DE   0x2800             CMP      R0,#+0
   \      0x1E0   0xD106             BNE.N    ??HW_I2C_Read_24
   \      0x1E2   0x9800             LDR      R0,[SP, #+0]
   \      0x1E4   0x1E41             SUBS     R1,R0,#+1
   \      0x1E6   0x9100             STR      R1,[SP, #+0]
   \      0x1E8   0x2800             CMP      R0,#+0
   \      0x1EA   0xD1F4             BNE.N    ??HW_I2C_Read_23
   \      0x1EC   0x2000             MOVS     R0,#+0
   \      0x1EE   0xE05B             B.N      ??HW_I2C_Read_4
   \                     ??HW_I2C_Read_24: (+1)
   \      0x1F0   0x9600             STR      R6,[SP, #+0]
   \      0x1F2   0x2201             MOVS     R2,#+1
   \      0x1F4   0x0029             MOVS     R1,R5
   \      0x1F6   0xB2C9             UXTB     R1,R1
   \      0x1F8   0x0020             MOVS     R0,R4
   \      0x1FA   0x.... 0x....      BL       I2C_Send7bitAddress
   \                     ??HW_I2C_Read_25: (+1)
   \      0x1FE   0x.... 0x....      LDR.W    R1,??DataTable12_14
   \      0x202   0x0020             MOVS     R0,R4
   \      0x204   0x.... 0x....      BL       I2C_CheckEvent
   \      0x208   0x2800             CMP      R0,#+0
   \      0x20A   0xD141             BNE.N    ??HW_I2C_Read_26
   \                     ??HW_I2C_Read_27: (+1)
   \      0x20C   0x9800             LDR      R0,[SP, #+0]
   \      0x20E   0x1E41             SUBS     R1,R0,#+1
   \      0x210   0x9100             STR      R1,[SP, #+0]
   \      0x212   0x2800             CMP      R0,#+0
   \      0x214   0xD1F3             BNE.N    ??HW_I2C_Read_25
   \      0x216   0xE7D4             B.N      ??HW_I2C_Read_22
    181              }
    182          
    183              /* While there is data to be read; here the safe procedure is implemented */
    184              while (NumByteToRead)
    185              {
    186          
    187                if (NumByteToRead != 3) /* Receive bytes from first byte until byte N-3 */
   \                     ??HW_I2C_Read_28: (+1)
   \      0x218   0x4648             MOV      R0,R9
   \      0x21A   0xB280             UXTH     R0,R0
   \      0x21C   0x2803             CMP      R0,#+3
   \      0x21E   0xD00D             BEQ.N    ??HW_I2C_Read_29
    188                {
    189                  while ((I2C_GetLastEvent(I2Cx) & 0x00004) != 0x000004); /* Poll on BTF */
   \                     ??HW_I2C_Read_30: (+1)
   \      0x220   0x0020             MOVS     R0,R4
   \      0x222   0x.... 0x....      BL       I2C_GetLastEvent
   \      0x226   0x0740             LSLS     R0,R0,#+29
   \      0x228   0xD5FA             BPL.N    ??HW_I2C_Read_30
    190                  /* Read data */
    191                  *pBuffer = I2C_ReceiveData(I2Cx);
   \      0x22A   0x0020             MOVS     R0,R4
   \      0x22C   0x.... 0x....      BL       I2C_ReceiveData
   \      0x230   0xF888 0x0000      STRB     R0,[R8, #+0]
    192                  pBuffer++;
   \      0x234   0xF118 0x0801      ADDS     R8,R8,#+1
    193                  /* Decrement the read bytes counter */
    194                  NumByteToRead--;
   \      0x238   0xF1B9 0x0901      SUBS     R9,R9,#+1
    195                }
    196          
    197                if (NumByteToRead == 3)  /* it remains to read three data: data N-2, data N-1, Data N */
   \                     ??HW_I2C_Read_29: (+1)
   \      0x23C   0x4648             MOV      R0,R9
   \      0x23E   0xB280             UXTH     R0,R0
   \      0x240   0x2803             CMP      R0,#+3
   \      0x242   0xD125             BNE.N    ??HW_I2C_Read_26
    198                {
    199          
    200                  /* Data N-2 in DR and data N -1 in shift register */
    201                  while ((I2C_GetLastEvent(I2Cx) & 0x000004) != 0x0000004); /* Poll on BTF */
   \                     ??HW_I2C_Read_31: (+1)
   \      0x244   0x0020             MOVS     R0,R4
   \      0x246   0x.... 0x....      BL       I2C_GetLastEvent
   \      0x24A   0x0740             LSLS     R0,R0,#+29
   \      0x24C   0xD5FA             BPL.N    ??HW_I2C_Read_31
    202                  /* Clear ACK */
    203                  I2C_AcknowledgeConfig(I2Cx, DISABLE);
   \      0x24E   0x2100             MOVS     R1,#+0
   \      0x250   0x0020             MOVS     R0,R4
   \      0x252   0x.... 0x....      BL       I2C_AcknowledgeConfig
    204                  __disable_irq();
   \      0x256   0xB672             CPSID    I
    205                  /* Read Data N-2 */
    206                  *pBuffer = I2C_ReceiveData(I2Cx);
   \      0x258   0x0020             MOVS     R0,R4
   \      0x25A   0x.... 0x....      BL       I2C_ReceiveData
   \      0x25E   0xF888 0x0000      STRB     R0,[R8, #+0]
    207                  pBuffer++;
   \      0x262   0xF118 0x0501      ADDS     R5,R8,#+1
    208                  /* Program the STOP */
    209                  I2C_GenerateSTOP(I2Cx, ENABLE);
   \      0x266   0x2101             MOVS     R1,#+1
   \      0x268   0x0020             MOVS     R0,R4
   \      0x26A   0x.... 0x....      BL       I2C_GenerateSTOP
    210                  /* Read DataN-1 */
    211                  *pBuffer = I2C_ReceiveData(I2Cx);
   \      0x26E   0x0020             MOVS     R0,R4
   \      0x270   0x.... 0x....      BL       I2C_ReceiveData
   \      0x274   0x7028             STRB     R0,[R5, #+0]
    212                  __enable_irq();
   \      0x276   0xB662             CPSIE    I
    213                  pBuffer++;
   \      0x278   0xF115 0x0801      ADDS     R8,R5,#+1
    214                  while ((I2C_GetLastEvent(I2Cx) & 0x00000040) != 0x0000040); /* Poll on RxNE */
   \                     ??HW_I2C_Read_32: (+1)
   \      0x27C   0x0020             MOVS     R0,R4
   \      0x27E   0x.... 0x....      BL       I2C_GetLastEvent
   \      0x282   0x0640             LSLS     R0,R0,#+25
   \      0x284   0xD5FA             BPL.N    ??HW_I2C_Read_32
    215                  /* Read DataN */
    216                  *pBuffer = I2Cx->DR;
   \      0x286   0x8A20             LDRH     R0,[R4, #+16]
   \      0x288   0xF888 0x0000      STRB     R0,[R8, #+0]
    217                  /* Reset the number of bytes to be read by master */
    218                  NumByteToRead = 0;
   \      0x28C   0xF05F 0x0900      MOVS     R9,#+0
    219                }
    220              }
   \                     ??HW_I2C_Read_26: (+1)
   \      0x290   0x4648             MOV      R0,R9
   \      0x292   0xB280             UXTH     R0,R0
   \      0x294   0x2800             CMP      R0,#+0
   \      0x296   0xD1BF             BNE.N    ??HW_I2C_Read_28
    221              /* Make sure that the STOP bit is cleared by Hardware before CR1 write access */
    222              while ((I2Cx->CR1&0x200) == 0x200);
   \                     ??HW_I2C_Read_33: (+1)
   \      0x298   0x8820             LDRH     R0,[R4, #+0]
   \      0x29A   0x0580             LSLS     R0,R0,#+22
   \      0x29C   0xD4FC             BMI.N    ??HW_I2C_Read_33
    223              /* Enable Acknowledgement to be ready for another reception */
    224              I2C_AcknowledgeConfig(I2Cx, ENABLE);
   \      0x29E   0x2101             MOVS     R1,#+1
   \      0x2A0   0x0020             MOVS     R0,R4
   \      0x2A2   0x.... 0x....      BL       I2C_AcknowledgeConfig
    225          
    226              return SUCCESS;
   \      0x2A6   0x2001             MOVS     R0,#+1
   \                     ??HW_I2C_Read_4: (+1)
   \      0x2A8   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    227            }
    228          }
    229          

   \                                 In section .text, align 2, keep-with-next
    230          uint8_t HW_I2C_Write(I2C_TypeDef* I2Cx, uint8_t DeviceAddr, uint8_t RegisterAddr,
    231                                         uint16_t NumByteToWrite,
    232                                         uint8_t* pBuffer)
    233          {
   \                     HW_I2C_Write: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
    234            __IO uint32_t UTIL_Timeout = LONG_TIMEOUT;
   \        0xC   0xF44F 0x4820      MOV      R8,#+40960
   \       0x10   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x14   0xE004             B.N      ??HW_I2C_Write_0
    235          
    236           restart1:
    237            UTIL_Timeout = LONG_TIMEOUT;
    238            /* Send START condition */
    239            I2C_GenerateSTART(I2Cx, ENABLE);
    240            /* Test on EV5 and clear it */
    241            while (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_MODE_SELECT))
    242            {
    243              if (UTIL_Timeout-- == 0) return ERROR;
    244            }
    245            /* Send slave address for write */
    246            I2C_Send7bitAddress(I2Cx, DeviceAddr, I2C_Direction_Transmitter);
    247          
    248            UTIL_Timeout = LONG_TIMEOUT;
    249            /* Test on EV6 and clear it */
    250            while (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
    251             {
    252          
    253              if (UTIL_Timeout-- == 0)
    254              {
    255                I2C_ClearFlag(I2Cx,I2C_FLAG_BUSY|I2C_FLAG_AF);
   \                     ??HW_I2C_Write_1: (+1)
   \       0x16   0x.... 0x....      LDR.W    R1,??DataTable12_9
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0x.... 0x....      BL       I2C_ClearFlag
    256                goto restart1;
    257              }
   \                     ??HW_I2C_Write_0: (+1)
   \       0x20   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x24   0x2101             MOVS     R1,#+1
   \       0x26   0x0020             MOVS     R0,R4
   \       0x28   0x.... 0x....      BL       I2C_GenerateSTART
   \                     ??HW_I2C_Write_2: (+1)
   \       0x2C   0x.... 0x....      LDR.W    R1,??DataTable12_10
   \       0x30   0x0020             MOVS     R0,R4
   \       0x32   0x.... 0x....      BL       I2C_CheckEvent
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD106             BNE.N    ??HW_I2C_Write_3
   \       0x3A   0x9800             LDR      R0,[SP, #+0]
   \       0x3C   0x1E41             SUBS     R1,R0,#+1
   \       0x3E   0x9100             STR      R1,[SP, #+0]
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD1F3             BNE.N    ??HW_I2C_Write_2
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0xE075             B.N      ??HW_I2C_Write_4
   \                     ??HW_I2C_Write_3: (+1)
   \       0x48   0x2200             MOVS     R2,#+0
   \       0x4A   0x0029             MOVS     R1,R5
   \       0x4C   0xB2C9             UXTB     R1,R1
   \       0x4E   0x0020             MOVS     R0,R4
   \       0x50   0x.... 0x....      BL       I2C_Send7bitAddress
   \       0x54   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \                     ??HW_I2C_Write_5: (+1)
   \       0x58   0x.... 0x....      LDR.W    R1,??DataTable12_11
   \       0x5C   0x0020             MOVS     R0,R4
   \       0x5E   0x.... 0x....      BL       I2C_CheckEvent
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD105             BNE.N    ??HW_I2C_Write_6
   \                     ??HW_I2C_Write_7: (+1)
   \       0x66   0x9800             LDR      R0,[SP, #+0]
   \       0x68   0x1E41             SUBS     R1,R0,#+1
   \       0x6A   0x9100             STR      R1,[SP, #+0]
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0xD1F3             BNE.N    ??HW_I2C_Write_5
   \       0x70   0xE7D1             B.N      ??HW_I2C_Write_1
    258            }
    259            
    260            UTIL_Timeout = LONG_TIMEOUT;
   \                     ??HW_I2C_Write_6: (+1)
   \       0x72   0xF8CD 0x8000      STR      R8,[SP, #+0]
    261          
    262            /* Transmit the first address for r/w operations */
    263            I2C_SendData(I2Cx, RegisterAddr);
   \       0x76   0x0031             MOVS     R1,R6
   \       0x78   0xB2C9             UXTB     R1,R1
   \       0x7A   0x0020             MOVS     R0,R4
   \       0x7C   0x.... 0x....      BL       I2C_SendData
    264          
    265            /* Test on EV8 and clear it */
    266            while (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
   \                     ??HW_I2C_Write_8: (+1)
   \       0x80   0x.... 0x....      LDR.W    R5,??DataTable12_12
   \       0x84   0x0029             MOVS     R1,R5
   \       0x86   0x0020             MOVS     R0,R4
   \       0x88   0x.... 0x....      BL       I2C_CheckEvent
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0xD106             BNE.N    ??HW_I2C_Write_9
    267            {
    268              if (UTIL_Timeout-- == 0)
   \       0x90   0x9800             LDR      R0,[SP, #+0]
   \       0x92   0x1E41             SUBS     R1,R0,#+1
   \       0x94   0x9100             STR      R1,[SP, #+0]
   \       0x96   0x2800             CMP      R0,#+0
   \       0x98   0xD1F2             BNE.N    ??HW_I2C_Write_8
    269                return ERROR;
   \       0x9A   0x2000             MOVS     R0,#+0
   \       0x9C   0xE04A             B.N      ??HW_I2C_Write_4
    270            }
   \                     ??HW_I2C_Write_9: (+1)
   \       0x9E   0x9E08             LDR      R6,[SP, #+32]
    271            if (NumByteToWrite == 0x01)
   \       0xA0   0x0038             MOVS     R0,R7
   \       0xA2   0xB280             UXTH     R0,R0
   \       0xA4   0x2801             CMP      R0,#+1
   \       0xA6   0xD118             BNE.N    ??HW_I2C_Write_10
    272            {
    273              UTIL_Timeout = LONG_TIMEOUT;
   \       0xA8   0xF8CD 0x8000      STR      R8,[SP, #+0]
    274              /* Prepare the register value to be sent */
    275              I2C_SendData(I2Cx, *pBuffer);
   \       0xAC   0x7831             LDRB     R1,[R6, #+0]
   \       0xAE   0x0020             MOVS     R0,R4
   \       0xB0   0x.... 0x....      BL       I2C_SendData
    276          
    277              /* Test on EV8 and clear it */
    278              while (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
   \                     ??HW_I2C_Write_11: (+1)
   \       0xB4   0x0029             MOVS     R1,R5
   \       0xB6   0x0020             MOVS     R0,R4
   \       0xB8   0x.... 0x....      BL       I2C_CheckEvent
   \       0xBC   0x2800             CMP      R0,#+0
   \       0xBE   0xD106             BNE.N    ??HW_I2C_Write_12
    279              {
    280                if (UTIL_Timeout-- == 0)
   \       0xC0   0x9800             LDR      R0,[SP, #+0]
   \       0xC2   0x1E41             SUBS     R1,R0,#+1
   \       0xC4   0x9100             STR      R1,[SP, #+0]
   \       0xC6   0x2800             CMP      R0,#+0
   \       0xC8   0xD1F4             BNE.N    ??HW_I2C_Write_11
    281                  return ERROR;
   \       0xCA   0x2000             MOVS     R0,#+0
   \       0xCC   0xE032             B.N      ??HW_I2C_Write_4
    282              }
    283          
    284              /* End the configuration sequence */
    285              I2C_GenerateSTOP(I2Cx, ENABLE);
   \                     ??HW_I2C_Write_12: (+1)
   \       0xCE   0x2101             MOVS     R1,#+1
   \       0xD0   0x0020             MOVS     R0,R4
   \       0xD2   0x.... 0x....      BL       I2C_GenerateSTOP
    286              return SUCCESS;
   \       0xD6   0x2001             MOVS     R0,#+1
   \       0xD8   0xE02C             B.N      ??HW_I2C_Write_4
    287            }
    288            I2C_SendData(I2Cx, *pBuffer);
   \                     ??HW_I2C_Write_10: (+1)
   \       0xDA   0x7831             LDRB     R1,[R6, #+0]
   \       0xDC   0x0020             MOVS     R0,R4
   \       0xDE   0x.... 0x....      BL       I2C_SendData
    289            pBuffer++;
   \       0xE2   0xF116 0x0901      ADDS     R9,R6,#+1
    290            NumByteToWrite--;
   \       0xE6   0x1E7E             SUBS     R6,R7,#+1
   \       0xE8   0xE00B             B.N      ??HW_I2C_Write_13
    291            /* While there is data to be written */
    292            while (NumByteToWrite--)
    293            {
    294              while ((I2C_GetLastEvent(I2Cx) & 0x04) != 0x04);  /* Poll on BTF */
   \                     ??HW_I2C_Write_14: (+1)
   \       0xEA   0x0020             MOVS     R0,R4
   \       0xEC   0x.... 0x....      BL       I2C_GetLastEvent
   \       0xF0   0x0740             LSLS     R0,R0,#+29
   \       0xF2   0xD5FA             BPL.N    ??HW_I2C_Write_14
    295              /* Send the current byte */
    296              I2C_SendData(I2Cx, *pBuffer);
   \       0xF4   0xF899 0x1000      LDRB     R1,[R9, #+0]
   \       0xF8   0x0020             MOVS     R0,R4
   \       0xFA   0x.... 0x....      BL       I2C_SendData
    297              /* Point to the next byte to be written */
    298              pBuffer++;
   \       0xFE   0xF119 0x0901      ADDS     R9,R9,#+1
    299          
    300            }
   \                     ??HW_I2C_Write_13: (+1)
   \      0x102   0x0030             MOVS     R0,R6
   \      0x104   0x1E46             SUBS     R6,R0,#+1
   \      0x106   0xB280             UXTH     R0,R0
   \      0x108   0x2800             CMP      R0,#+0
   \      0x10A   0xD1EE             BNE.N    ??HW_I2C_Write_14
    301            UTIL_Timeout = LONG_TIMEOUT;
   \      0x10C   0xF8CD 0x8000      STR      R8,[SP, #+0]
    302            /* Test on EV8_2 and clear it, BTF = TxE = 1, DR and shift registers are
    303             empty */
    304            while (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
   \                     ??HW_I2C_Write_15: (+1)
   \      0x110   0x0029             MOVS     R1,R5
   \      0x112   0x0020             MOVS     R0,R4
   \      0x114   0x.... 0x....      BL       I2C_CheckEvent
   \      0x118   0x2800             CMP      R0,#+0
   \      0x11A   0xD106             BNE.N    ??HW_I2C_Write_16
    305            {
    306              if (UTIL_Timeout-- == 0) return ERROR;
   \      0x11C   0x9800             LDR      R0,[SP, #+0]
   \      0x11E   0x1E41             SUBS     R1,R0,#+1
   \      0x120   0x9100             STR      R1,[SP, #+0]
   \      0x122   0x2800             CMP      R0,#+0
   \      0x124   0xD1F4             BNE.N    ??HW_I2C_Write_15
   \      0x126   0x2000             MOVS     R0,#+0
   \      0x128   0xE004             B.N      ??HW_I2C_Write_4
    307            }
    308            /* Send STOP condition */
    309            I2C_GenerateSTOP(I2Cx, ENABLE);
   \                     ??HW_I2C_Write_16: (+1)
   \      0x12A   0x2101             MOVS     R1,#+1
   \      0x12C   0x0020             MOVS     R0,R4
   \      0x12E   0x.... 0x....      BL       I2C_GenerateSTOP
    310            return SUCCESS;
   \      0x132   0x2001             MOVS     R0,#+1
   \                     ??HW_I2C_Write_4: (+1)
   \      0x134   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    311          }
    312          
    313          /*
    314          DS3231로부터 읽어 온 시간 데이터를 출력하는 함수
    315          시간 영역에 저장된 값(시간 구조체->hour_select->am_pm_24)을 판단해
    316          AM, PM, 24시간 표기로 구분한 뒤 출력
    317          */

   \                                 In section .text, align 2, keep-with-next
    318          void ds3231_print_time(ds3231_time *current_time)
    319          {
   \                     ds3231_print_time: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
   \        0x4   0x0004             MOVS     R4,R0
    320                  char time[20] = "";
   \        0x6   0xA803             ADD      R0,SP,#+12
   \        0x8   0x2114             MOVS     R1,#+20
   \        0xA   0x.... 0x....      BL       __aeabi_memclr
    321                  char sprin_result[5] = "";
   \        0xE   0xA801             ADD      R0,SP,#+4
   \       0x10   0x2105             MOVS     R1,#+5
   \       0x12   0x.... 0x....      BL       __aeabi_memclr
    322                  
    323          	printf("%d-%d-%d",current_time->year,current_time->month
    324          			,current_time->date);
   \       0x16   0x7963             LDRB     R3,[R4, #+5]
   \       0x18   0x79A2             LDRB     R2,[R4, #+6]
   \       0x1A   0x79E1             LDRB     R1,[R4, #+7]
   \       0x1C   0x.... 0x....      LDR.W    R0,??DataTable12_15
   \       0x20   0x.... 0x....      BL       printf
    325                  
    326                  sprintf(sprin_result, "%d", current_time->year);
   \       0x24   0x....             ADR.N    R5,??DataTable6
   \       0x26   0x79E2             LDRB     R2,[R4, #+7]
   \       0x28   0x0029             MOVS     R1,R5
   \       0x2A   0xA801             ADD      R0,SP,#+4
   \       0x2C   0x.... 0x....      BL       sprintf
    327                  strcat(time, sprin_result);
   \       0x30   0xA901             ADD      R1,SP,#+4
   \       0x32   0xA803             ADD      R0,SP,#+12
   \       0x34   0x.... 0x....      BL       strcat
    328                  strcat(time, "-");
   \       0x38   0x....             ADR.N    R6,??DataTable6_1
   \       0x3A   0x0031             MOVS     R1,R6
   \       0x3C   0x.... 0x....      BL       strcat
    329                  sprintf(sprin_result, "%d", current_time->month);
   \       0x40   0x79A2             LDRB     R2,[R4, #+6]
   \       0x42   0x0029             MOVS     R1,R5
   \       0x44   0xA801             ADD      R0,SP,#+4
   \       0x46   0x.... 0x....      BL       sprintf
    330                  strcat(time, sprin_result);
   \       0x4A   0xA901             ADD      R1,SP,#+4
   \       0x4C   0xA803             ADD      R0,SP,#+12
   \       0x4E   0x.... 0x....      BL       strcat
    331                  strcat(time, "-");
   \       0x52   0x0031             MOVS     R1,R6
   \       0x54   0x.... 0x....      BL       strcat
    332                  sprintf(sprin_result, "%d", current_time->date);
   \       0x58   0x7962             LDRB     R2,[R4, #+5]
   \       0x5A   0x0029             MOVS     R1,R5
   \       0x5C   0xA801             ADD      R0,SP,#+4
   \       0x5E   0x.... 0x....      BL       sprintf
    333                  strcat(time, sprin_result);
   \       0x62   0xA901             ADD      R1,SP,#+4
   \       0x64   0xA803             ADD      R0,SP,#+12
   \       0x66   0x.... 0x....      BL       strcat
    334                  strcat(time, " ");
   \       0x6A   0x....             ADR.N    R1,??DataTable6_2
   \       0x6C   0x.... 0x....      BL       strcat
    335                  
    336          	switch (current_time->hour_select.am_pm_24)
   \       0x70   0x78A0             LDRB     R0,[R4, #+2]
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD003             BEQ.N    ??ds3231_print_time_0
   \       0x76   0x2802             CMP      R0,#+2
   \       0x78   0xD037             BEQ.N    ??ds3231_print_time_1
   \       0x7A   0xD31B             BCC.N    ??ds3231_print_time_2
   \       0x7C   0xE04C             B.N      ??ds3231_print_time_3
    337          	{
    338          		//12시간 표기의 경우 0~4번 비트까지 유효한 시간 데이터, 5~6번 비트는 시간 표기 설정 비트
    339          		case ds3231_AM :
    340                            printf("AM : %d:",(current_time->hour_select.hour)&0x1F);	
   \                     ??ds3231_print_time_0: (+1)
   \       0x7E   0x78E1             LDRB     R1,[R4, #+3]
   \       0x80   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \       0x84   0x.... 0x....      LDR.W    R0,??DataTable12_16
   \       0x88   0x.... 0x....      BL       printf
    341                            strcat(time, "AM : ");
   \       0x8C   0x.... 0x....      LDR.W    R1,??DataTable12_17
   \       0x90   0xA803             ADD      R0,SP,#+12
   \       0x92   0x.... 0x....      BL       strcat
    342                            sprintf(sprin_result, "%d", (current_time->hour_select.hour)&0x1F);
   \       0x96   0x78E2             LDRB     R2,[R4, #+3]
   \       0x98   0xF012 0x021F      ANDS     R2,R2,#0x1F
   \       0x9C   0x0029             MOVS     R1,R5
   \       0x9E   0xA801             ADD      R0,SP,#+4
   \       0xA0   0x.... 0x....      BL       sprintf
    343                            strcat(time, sprin_result);
   \       0xA4   0xA901             ADD      R1,SP,#+4
   \       0xA6   0xA803             ADD      R0,SP,#+12
   \       0xA8   0x.... 0x....      BL       strcat
    344                            strcat(time, ":");
   \       0xAC   0x....             ADR.N    R1,??DataTable7
   \       0xAE   0x.... 0x....      BL       strcat
    345          			break;
   \       0xB2   0xE031             B.N      ??ds3231_print_time_4
    346          		case ds3231_PM :
    347                            printf("PM : %d:",(current_time->hour_select.hour)&0x1F);
   \                     ??ds3231_print_time_2: (+1)
   \       0xB4   0x78E1             LDRB     R1,[R4, #+3]
   \       0xB6   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \       0xBA   0x.... 0x....      LDR.W    R0,??DataTable12_18
   \       0xBE   0x.... 0x....      BL       printf
    348                            strcat(time, "PM : ");
   \       0xC2   0x.... 0x....      LDR.W    R1,??DataTable12_19
   \       0xC6   0xA803             ADD      R0,SP,#+12
   \       0xC8   0x.... 0x....      BL       strcat
    349                            sprintf(sprin_result, "%d", (current_time->hour_select.hour)&0x1F);
   \       0xCC   0x78E2             LDRB     R2,[R4, #+3]
   \       0xCE   0xF012 0x021F      ANDS     R2,R2,#0x1F
   \       0xD2   0x0029             MOVS     R1,R5
   \       0xD4   0xA801             ADD      R0,SP,#+4
   \       0xD6   0x.... 0x....      BL       sprintf
    350                            strcat(time, sprin_result);
   \       0xDA   0xA901             ADD      R1,SP,#+4
   \       0xDC   0xA803             ADD      R0,SP,#+12
   \       0xDE   0x.... 0x....      BL       strcat
    351                            strcat(time, ":");
   \       0xE2   0x....             ADR.N    R1,??DataTable7
   \       0xE4   0x.... 0x....      BL       strcat
    352          			break;
   \       0xE8   0xE016             B.N      ??ds3231_print_time_4
    353          		case ds3231_24_hour :
    354                            printf("24 : %d:",current_time->hour_select.hour);
   \                     ??ds3231_print_time_1: (+1)
   \       0xEA   0x78E1             LDRB     R1,[R4, #+3]
   \       0xEC   0x.... 0x....      LDR.W    R0,??DataTable12_20
   \       0xF0   0x.... 0x....      BL       printf
    355                            strcat(time, "24 : ");
   \       0xF4   0x.... 0x....      LDR.W    R1,??DataTable12_21
   \       0xF8   0xA803             ADD      R0,SP,#+12
   \       0xFA   0x.... 0x....      BL       strcat
    356                            sprintf(sprin_result, "%d", current_time->hour_select.hour);
   \       0xFE   0x78E2             LDRB     R2,[R4, #+3]
   \      0x100   0x0029             MOVS     R1,R5
   \      0x102   0xA801             ADD      R0,SP,#+4
   \      0x104   0x.... 0x....      BL       sprintf
    357                            strcat(time, sprin_result);
   \      0x108   0xA901             ADD      R1,SP,#+4
   \      0x10A   0xA803             ADD      R0,SP,#+12
   \      0x10C   0x.... 0x....      BL       strcat
    358                            strcat(time, ":");
   \      0x110   0x....             ADR.N    R1,??DataTable7
   \      0x112   0x.... 0x....      BL       strcat
    359          			break;
   \      0x116   0xE7FF             B.N      ??ds3231_print_time_4
    360          		default :
    361          			break;
    362          	}
    363                  
    364          	printf("%d:%d\r\n",current_time->min,current_time->sec);
   \                     ??ds3231_print_time_3: (+1)
   \                     ??ds3231_print_time_4: (+1)
   \      0x118   0x7822             LDRB     R2,[R4, #+0]
   \      0x11A   0x7861             LDRB     R1,[R4, #+1]
   \      0x11C   0x.... 0x....      LDR.W    R0,??DataTable12_22
   \      0x120   0x.... 0x....      BL       printf
    365                  
    366                  sprintf(sprin_result, "%d", current_time->min);
   \      0x124   0x7862             LDRB     R2,[R4, #+1]
   \      0x126   0x0029             MOVS     R1,R5
   \      0x128   0xA801             ADD      R0,SP,#+4
   \      0x12A   0x.... 0x....      BL       sprintf
    367                  strcat(time, sprin_result);
   \      0x12E   0xA901             ADD      R1,SP,#+4
   \      0x130   0xA803             ADD      R0,SP,#+12
   \      0x132   0x.... 0x....      BL       strcat
    368                  strcat(time, ":");
   \      0x136   0x....             ADR.N    R1,??DataTable7
   \      0x138   0x.... 0x....      BL       strcat
    369                  sprintf(sprin_result, "%d", current_time->sec);
   \      0x13C   0x7822             LDRB     R2,[R4, #+0]
   \      0x13E   0x0029             MOVS     R1,R5
   \      0x140   0xA801             ADD      R0,SP,#+4
   \      0x142   0x.... 0x....      BL       sprintf
    370                  strcat(time, sprin_result);
   \      0x146   0xA901             ADD      R1,SP,#+4
   \      0x148   0xA803             ADD      R0,SP,#+12
   \      0x14A   0x.... 0x....      BL       strcat
   \      0x14E   0x0001             MOVS     R1,R0
    371                  
    372                  printf("String : %s\n", time);
   \      0x150   0x.... 0x....      LDR.W    R0,??DataTable12_23
   \      0x154   0x.... 0x....      BL       printf
    373                  
    374                  LCD_ShowString(25, 100, time, BLACK, WHITE);
                                                 ^
Warning[Pe167]: argument of type "char *" is incompatible with parameter of
          type "u8 *"
   \      0x158   0xF64F 0x70FF      MOVW     R0,#+65535
   \      0x15C   0x9000             STR      R0,[SP, #+0]
   \      0x15E   0x2300             MOVS     R3,#+0
   \      0x160   0xAA03             ADD      R2,SP,#+12
   \      0x162   0x2164             MOVS     R1,#+100
   \      0x164   0x2019             MOVS     R0,#+25
   \      0x166   0x.... 0x....      BL       LCD_ShowString
    375          
    376          }
   \      0x16A   0xB008             ADD      SP,SP,#+32
   \      0x16C   0xBD70             POP      {R4-R6,PC}

   \                                 In section .rodata, align 1
   \        0x0   0x00               DC8 ""
   \        0x1                      DS8 19

   \                                 In section .rodata, align 1
   \        0x0   0x00               DC8 ""
   \        0x1                      DS8 4
    377          
    378          /*
    379          전달받은 시간 구조체 주소에 DS3231로부터 읽어 온 시간 데이터를 저장하는 함수
    380          */

   \                                 In section .text, align 2, keep-with-next
    381          void ds3231_read_time(ds3231_time *current_time)
    382          {
   \                     ds3231_read_time: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    383          	uint8_t ds3231_read_time_buff[7];	
    384          	//DS3231로부터 읽어 올 데이터를 저장할 데이터 버퍼 (초,분,시간,요일,날짜,달,년도-총 7개)
    385              
    386          	/*
    387          	특정 메모리 주소에 액세스해서 원하는 갯수만큼 데이터를 읽어와서 데이터 버퍼에 저장
    388          	*/
    389          	HW_I2C_Read(I2C1, ds3231_addr,ds3231_sec_addr, 1, &ds3231_read_time_buff[0]);
   \        0x4   0x.... 0x....      LDR.W    R5,??DataTable12_5
   \        0x8   0xA801             ADD      R0,SP,#+4
   \        0xA   0x9000             STR      R0,[SP, #+0]
   \        0xC   0x2301             MOVS     R3,#+1
   \        0xE   0x2200             MOVS     R2,#+0
   \       0x10   0x21D0             MOVS     R1,#+208
   \       0x12   0x0028             MOVS     R0,R5
   \       0x14   0x.... 0x....      BL       HW_I2C_Read
    390          	HW_I2C_Read(I2C1, ds3231_addr,ds3231_min_addr, 1, &ds3231_read_time_buff[1]);
   \       0x18   0xF10D 0x0005      ADD      R0,SP,#+5
   \       0x1C   0x9000             STR      R0,[SP, #+0]
   \       0x1E   0x2301             MOVS     R3,#+1
   \       0x20   0x2201             MOVS     R2,#+1
   \       0x22   0x21D0             MOVS     R1,#+208
   \       0x24   0x0028             MOVS     R0,R5
   \       0x26   0x.... 0x....      BL       HW_I2C_Read
    391          	HW_I2C_Read(I2C1, ds3231_addr,ds3231_hour_addr, 1, &ds3231_read_time_buff[2]);
   \       0x2A   0xF10D 0x0006      ADD      R0,SP,#+6
   \       0x2E   0x9000             STR      R0,[SP, #+0]
   \       0x30   0x2301             MOVS     R3,#+1
   \       0x32   0x2202             MOVS     R2,#+2
   \       0x34   0x21D0             MOVS     R1,#+208
   \       0x36   0x0028             MOVS     R0,R5
   \       0x38   0x.... 0x....      BL       HW_I2C_Read
    392          	HW_I2C_Read(I2C1, ds3231_addr,ds3231_day_addr, 1, &ds3231_read_time_buff[3]);
   \       0x3C   0xF10D 0x0007      ADD      R0,SP,#+7
   \       0x40   0x9000             STR      R0,[SP, #+0]
   \       0x42   0x2301             MOVS     R3,#+1
   \       0x44   0x2203             MOVS     R2,#+3
   \       0x46   0x21D0             MOVS     R1,#+208
   \       0x48   0x0028             MOVS     R0,R5
   \       0x4A   0x.... 0x....      BL       HW_I2C_Read
    393          	HW_I2C_Read(I2C1, ds3231_addr,ds3231_date_addr, 1, &ds3231_read_time_buff[4]);
   \       0x4E   0xA802             ADD      R0,SP,#+8
   \       0x50   0x9000             STR      R0,[SP, #+0]
   \       0x52   0x2301             MOVS     R3,#+1
   \       0x54   0x2204             MOVS     R2,#+4
   \       0x56   0x21D0             MOVS     R1,#+208
   \       0x58   0x0028             MOVS     R0,R5
   \       0x5A   0x.... 0x....      BL       HW_I2C_Read
    394          	HW_I2C_Read(I2C1, ds3231_addr,ds3231_month_addr, 1, &ds3231_read_time_buff[5]);
   \       0x5E   0xF10D 0x0009      ADD      R0,SP,#+9
   \       0x62   0x9000             STR      R0,[SP, #+0]
   \       0x64   0x2301             MOVS     R3,#+1
   \       0x66   0x2205             MOVS     R2,#+5
   \       0x68   0x21D0             MOVS     R1,#+208
   \       0x6A   0x0028             MOVS     R0,R5
   \       0x6C   0x.... 0x....      BL       HW_I2C_Read
    395          	HW_I2C_Read(I2C1, ds3231_addr,ds3231_year_addr, 1, &ds3231_read_time_buff[6]);
   \       0x70   0xF10D 0x000A      ADD      R0,SP,#+10
   \       0x74   0x9000             STR      R0,[SP, #+0]
   \       0x76   0x2301             MOVS     R3,#+1
   \       0x78   0x2206             MOVS     R2,#+6
   \       0x7A   0x21D0             MOVS     R1,#+208
   \       0x7C   0x0028             MOVS     R0,R5
   \       0x7E   0x.... 0x....      BL       HW_I2C_Read
    396          	//사용할 I2C, DS3231 주소, 접근할 DS3231 레지스터 주소, 메모리 블럭 크기, 읽어 온 데이터를 저장할 버퍼,
    397          	//읽어 올 데이터 갯수
    398              
    399          		//수신 완료 때까지 대기
    400          
    401          	/*
    402          	DS3231로부터 읽어 온 데이터를 10진수로 변환한 뒤 전달받은 구조체에 입력
    403          	*/
    404          	current_time->sec=bcdTodec(ds3231_read_time_buff[0]);
   \       0x82   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \       0x86   0x.... 0x....      BL       bcdTodec
   \       0x8A   0x7020             STRB     R0,[R4, #+0]
    405          	current_time->min=bcdTodec(ds3231_read_time_buff[1]);
   \       0x8C   0xAD01             ADD      R5,SP,#+4
   \       0x8E   0x7868             LDRB     R0,[R5, #+1]
   \       0x90   0x.... 0x....      BL       bcdTodec
   \       0x94   0x7060             STRB     R0,[R4, #+1]
    406          
    407          	/*
    408          	시간 레지스터(0x02)로부터 읽어 온 데이터의 6번 비트(0x40), 5번 비트(0x20)을 확인해 
    409          	High(1)로 설정되있을 경우 구조체 변수에 AM, PM 설정을 한다 (24시간 표기일 경우 6번 비트 Low(0))
    410          	*/
    411          	if((ds3231_read_time_buff[2]&0x40)!=0)	//BIT6!=0 이므로 12시간 표기
   \       0x96   0x78A8             LDRB     R0,[R5, #+2]
   \       0x98   0x0640             LSLS     R0,R0,#+25
   \       0x9A   0xD507             BPL.N    ??ds3231_read_time_0
    412          	{
    413          		if((ds3231_read_time_buff[2]&0x20)==0)	//BIT5==0 이므로 AM
   \       0x9C   0x78A8             LDRB     R0,[R5, #+2]
   \       0x9E   0x0680             LSLS     R0,R0,#+26
   \       0xA0   0xD402             BMI.N    ??ds3231_read_time_1
    414          		{
    415          			current_time->hour_select.am_pm_24=ds3231_AM;
   \       0xA2   0x2000             MOVS     R0,#+0
   \       0xA4   0x70A0             STRB     R0,[R4, #+2]
   \       0xA6   0xE001             B.N      ??ds3231_read_time_0
    416          		}
    417          		else	//BIT5!=0 이므로 PM
    418          		{
    419          			current_time->hour_select.am_pm_24=ds3231_PM;
   \                     ??ds3231_read_time_1: (+1)
   \       0xA8   0x2001             MOVS     R0,#+1
   \       0xAA   0x70A0             STRB     R0,[R4, #+2]
    420          		}
    421          	}
    422          	else
    423          	{
    424          		//24시간 표시 설정일 경우 (6번 비트 0, 5번 비트 2x 시간일 때만 1)
    425          	}
    426          	current_time->hour_select.hour=bcdTodec(ds3231_read_time_buff[2]);
   \                     ??ds3231_read_time_0: (+1)
   \       0xAC   0x78A8             LDRB     R0,[R5, #+2]
   \       0xAE   0x.... 0x....      BL       bcdTodec
   \       0xB2   0x70E0             STRB     R0,[R4, #+3]
    427          	current_time->day=bcdTodec(ds3231_read_time_buff[3]);
   \       0xB4   0x78E8             LDRB     R0,[R5, #+3]
   \       0xB6   0x.... 0x....      BL       bcdTodec
   \       0xBA   0x7120             STRB     R0,[R4, #+4]
    428          	current_time->date=bcdTodec(ds3231_read_time_buff[4]);
   \       0xBC   0x7928             LDRB     R0,[R5, #+4]
   \       0xBE   0x.... 0x....      BL       bcdTodec
   \       0xC2   0x7160             STRB     R0,[R4, #+5]
    429          	current_time->month=bcdTodec(ds3231_read_time_buff[5]);
   \       0xC4   0x7968             LDRB     R0,[R5, #+5]
   \       0xC6   0x.... 0x....      BL       bcdTodec
   \       0xCA   0x71A0             STRB     R0,[R4, #+6]
    430          	current_time->year=bcdTodec(ds3231_read_time_buff[6]);
   \       0xCC   0x79A8             LDRB     R0,[R5, #+6]
   \       0xCE   0x.... 0x....      BL       bcdTodec
   \       0xD2   0x71E0             STRB     R0,[R4, #+7]
    431          
    432          	ds3231_print_time(current_time);	//터미널에 출력할 함수 호출
   \       0xD4   0x0020             MOVS     R0,R4
   \       0xD6   0x.... 0x....      BL       ds3231_print_time
    433          }
   \       0xDA   0xBD37             POP      {R0-R2,R4,R5,PC}
    434          
    435          /*
    436          전달받은 구조체 주소를 통해 DS3231에 전송할 시간 데이터 버퍼를 채움
    437          */

   \                                 In section .text, align 2, keep-with-next
    438          void ds3231_write_time(ds3231_time *ds3231_write_time_struct)
    439          {
   \                     ds3231_write_time: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    440          	uint8_t write_buf[7];	//전송에 사용할 데이터 버퍼 배열 선언
    441          	
    442          	//입력한 10진수 시간 데이터를 2진수화
    443          	write_buf[0]=decTobcd(ds3231_write_time_struct->sec);
   \        0x4   0x7820             LDRB     R0,[R4, #+0]
   \        0x6   0x.... 0x....      BL       decTobcd
   \        0xA   0xF88D 0x0004      STRB     R0,[SP, #+4]
    444          	write_buf[1]=decTobcd(ds3231_write_time_struct->min);
   \        0xE   0xAD01             ADD      R5,SP,#+4
   \       0x10   0x7860             LDRB     R0,[R4, #+1]
   \       0x12   0x.... 0x....      BL       decTobcd
   \       0x16   0x7068             STRB     R0,[R5, #+1]
    445          	write_buf[2]=decTobcd(ds3231_write_time_struct->hour_select.hour);
   \       0x18   0x78E0             LDRB     R0,[R4, #+3]
   \       0x1A   0x.... 0x....      BL       decTobcd
   \       0x1E   0x70A8             STRB     R0,[R5, #+2]
    446          	write_buf[3]=decTobcd(ds3231_write_time_struct->day);
   \       0x20   0x7920             LDRB     R0,[R4, #+4]
   \       0x22   0x.... 0x....      BL       decTobcd
   \       0x26   0x70E8             STRB     R0,[R5, #+3]
    447          	write_buf[4]=decTobcd(ds3231_write_time_struct->date);
   \       0x28   0x7960             LDRB     R0,[R4, #+5]
   \       0x2A   0x.... 0x....      BL       decTobcd
   \       0x2E   0x7128             STRB     R0,[R5, #+4]
    448          	write_buf[5]=decTobcd(ds3231_write_time_struct->month);
   \       0x30   0x79A0             LDRB     R0,[R4, #+6]
   \       0x32   0x.... 0x....      BL       decTobcd
   \       0x36   0x7168             STRB     R0,[R5, #+5]
    449          	write_buf[6]=decTobcd(ds3231_write_time_struct->year);
   \       0x38   0x79E0             LDRB     R0,[R4, #+7]
   \       0x3A   0x.... 0x....      BL       decTobcd
   \       0x3E   0x71A8             STRB     R0,[R5, #+6]
    450          
    451          	/*
    452          	24시간 표기가 아닌 12시간 표기(AM/PM)을 사용하는 경우엔 
    453          	DS3231 시간(Hour) 레지스터(0x02)에 씌여질 데이터에 추가로 6, 5번 비트를 설정해줘야 한다
    454          	*/
    455          	switch(ds3231_write_time_struct->hour_select.am_pm_24)
   \       0x40   0x78A0             LDRB     R0,[R4, #+2]
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD003             BEQ.N    ??ds3231_write_time_0
   \       0x46   0x2802             CMP      R0,#+2
   \       0x48   0xD00B             BEQ.N    ??ds3231_write_time_1
   \       0x4A   0xD305             BCC.N    ??ds3231_write_time_2
   \       0x4C   0xE00A             B.N      ??ds3231_write_time_3
    456          	{
    457          		case ds3231_AM :	//AM인 경우 6번 비트(12/24)만 High로 설정해주면 된다
    458          			write_buf[2]|=0x40;
   \                     ??ds3231_write_time_0: (+1)
   \       0x4E   0x78A8             LDRB     R0,[R5, #+2]
   \       0x50   0xF050 0x0040      ORRS     R0,R0,#0x40
   \       0x54   0x70A8             STRB     R0,[R5, #+2]
    459          			break;
   \       0x56   0xE005             B.N      ??ds3231_write_time_4
    460          		case ds3231_PM :	//PM인 경우 6, 5번 비트를 High로 설정해줘야 한다
    461          			write_buf[2]|=0x60;
   \                     ??ds3231_write_time_2: (+1)
   \       0x58   0x78A8             LDRB     R0,[R5, #+2]
   \       0x5A   0xF050 0x0060      ORRS     R0,R0,#0x60
   \       0x5E   0x70A8             STRB     R0,[R5, #+2]
    462          			break;
   \       0x60   0xE000             B.N      ??ds3231_write_time_4
    463          		case ds3231_24_hour :
    464          			break;
   \                     ??ds3231_write_time_1: (+1)
   \       0x62   0xE7FF             B.N      ??ds3231_write_time_4
    465          		default :
    466          			break;
    467          	}
    468          
    469          	/*
    470          	DS3231 초(Sec) 레지스터(0x00)부터 7개의 8비트 데이터 배열을 입력
    471          	각 타임 레지스터는 8비트의 크기를 가지므로 0x00부터 0x06까지 순차적으로 8비트 데이터 7개가 입력된다
    472          	*/
    473                  
    474          	HW_I2C_Write(I2C1, ds3231_addr, ds3231_sec_addr, 1, &write_buf[0]);
   \                     ??ds3231_write_time_3: (+1)
   \                     ??ds3231_write_time_4: (+1)
   \       0x64   0x.... 0x....      LDR.W    R4,??DataTable12_5
   \       0x68   0xA801             ADD      R0,SP,#+4
   \       0x6A   0x9000             STR      R0,[SP, #+0]
   \       0x6C   0x2301             MOVS     R3,#+1
   \       0x6E   0x2200             MOVS     R2,#+0
   \       0x70   0x21D0             MOVS     R1,#+208
   \       0x72   0x0020             MOVS     R0,R4
   \       0x74   0x.... 0x....      BL       HW_I2C_Write
    475          	HW_I2C_Write(I2C1, ds3231_addr, ds3231_min_addr, 1, &write_buf[1]);
   \       0x78   0xF10D 0x0005      ADD      R0,SP,#+5
   \       0x7C   0x9000             STR      R0,[SP, #+0]
   \       0x7E   0x2301             MOVS     R3,#+1
   \       0x80   0x2201             MOVS     R2,#+1
   \       0x82   0x21D0             MOVS     R1,#+208
   \       0x84   0x0020             MOVS     R0,R4
   \       0x86   0x.... 0x....      BL       HW_I2C_Write
    476          	HW_I2C_Write(I2C1, ds3231_addr, ds3231_hour_addr, 1, &write_buf[2]);
   \       0x8A   0xF10D 0x0006      ADD      R0,SP,#+6
   \       0x8E   0x9000             STR      R0,[SP, #+0]
   \       0x90   0x2301             MOVS     R3,#+1
   \       0x92   0x2202             MOVS     R2,#+2
   \       0x94   0x21D0             MOVS     R1,#+208
   \       0x96   0x0020             MOVS     R0,R4
   \       0x98   0x.... 0x....      BL       HW_I2C_Write
    477          	HW_I2C_Write(I2C1, ds3231_addr, ds3231_day_addr, 1, &write_buf[3]);
   \       0x9C   0xF10D 0x0007      ADD      R0,SP,#+7
   \       0xA0   0x9000             STR      R0,[SP, #+0]
   \       0xA2   0x2301             MOVS     R3,#+1
   \       0xA4   0x2203             MOVS     R2,#+3
   \       0xA6   0x21D0             MOVS     R1,#+208
   \       0xA8   0x0020             MOVS     R0,R4
   \       0xAA   0x.... 0x....      BL       HW_I2C_Write
    478          	HW_I2C_Write(I2C1, ds3231_addr, ds3231_date_addr, 1, &write_buf[4]);
   \       0xAE   0xA802             ADD      R0,SP,#+8
   \       0xB0   0x9000             STR      R0,[SP, #+0]
   \       0xB2   0x2301             MOVS     R3,#+1
   \       0xB4   0x2204             MOVS     R2,#+4
   \       0xB6   0x21D0             MOVS     R1,#+208
   \       0xB8   0x0020             MOVS     R0,R4
   \       0xBA   0x.... 0x....      BL       HW_I2C_Write
    479          	HW_I2C_Write(I2C1, ds3231_addr, ds3231_month_addr, 1, &write_buf[5]);
   \       0xBE   0xF10D 0x0009      ADD      R0,SP,#+9
   \       0xC2   0x9000             STR      R0,[SP, #+0]
   \       0xC4   0x2301             MOVS     R3,#+1
   \       0xC6   0x2205             MOVS     R2,#+5
   \       0xC8   0x21D0             MOVS     R1,#+208
   \       0xCA   0x0020             MOVS     R0,R4
   \       0xCC   0x.... 0x....      BL       HW_I2C_Write
    480          	HW_I2C_Write(I2C1, ds3231_addr, ds3231_year_addr, 1, &write_buf[6]);
   \       0xD0   0xF10D 0x000A      ADD      R0,SP,#+10
   \       0xD4   0x9000             STR      R0,[SP, #+0]
   \       0xD6   0x2301             MOVS     R3,#+1
   \       0xD8   0x2206             MOVS     R2,#+6
   \       0xDA   0x21D0             MOVS     R1,#+208
   \       0xDC   0x0020             MOVS     R0,R4
   \       0xDE   0x.... 0x....      BL       HW_I2C_Write
    481                  
    482          		//입력 완료까지 대기
    483          }
   \       0xE2   0xBD37             POP      {R0-R2,R4,R5,PC}
    484          

   \                                 In section .text, align 2, keep-with-next
    485          void ds3231_set_alarm1(ds3231_Alarm1 *alarm1_data)
    486          {
   \                     ds3231_set_alarm1: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    487          	uint8_t alarm1_buff[4];	//DS3231에 전송할 알람1 데이터 버퍼
    488          
    489          	alarm1_buff[0]=decTobcd(alarm1_data->sec);	//초
   \        0x4   0x7820             LDRB     R0,[R4, #+0]
   \        0x6   0x.... 0x....      BL       decTobcd
   \        0xA   0xF88D 0x0004      STRB     R0,[SP, #+4]
    490          	alarm1_buff[1]=decTobcd(alarm1_data->min);	//분
   \        0xE   0xAD01             ADD      R5,SP,#+4
   \       0x10   0x7860             LDRB     R0,[R4, #+1]
   \       0x12   0x.... 0x....      BL       decTobcd
   \       0x16   0x7068             STRB     R0,[R5, #+1]
    491          	alarm1_buff[2]=decTobcd(alarm1_data->hour_select.hour);	//시간
   \       0x18   0x78E0             LDRB     R0,[R4, #+3]
   \       0x1A   0x.... 0x....      BL       decTobcd
   \       0x1E   0x70A8             STRB     R0,[R5, #+2]
    492          	alarm1_buff[3]=decTobcd(alarm1_data->day_date_select.value);	//날짜 or 요일값
   \       0x20   0x7960             LDRB     R0,[R4, #+5]
   \       0x22   0x.... 0x....      BL       decTobcd
   \       0x26   0x70E8             STRB     R0,[R5, #+3]
    493          
    494          	/*
    495          	12/24 시간 및 AM, PM 설정
    496          	*/
    497          	switch(alarm1_data->hour_select.am_pm_24)
   \       0x28   0x78A0             LDRB     R0,[R4, #+2]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD003             BEQ.N    ??ds3231_set_alarm1_0
   \       0x2E   0x2802             CMP      R0,#+2
   \       0x30   0xD00B             BEQ.N    ??ds3231_set_alarm1_1
   \       0x32   0xD305             BCC.N    ??ds3231_set_alarm1_2
   \       0x34   0xE00A             B.N      ??ds3231_set_alarm1_3
    498          	{
    499          		case ds3231_AM :	//전달된 구조체의 알람 시간이 AM일 경우
    500          			alarm1_buff[2]|=0x40;	//BIT6 Logic High=12시간 표기, BIT5 Logic Low=AM
   \                     ??ds3231_set_alarm1_0: (+1)
   \       0x36   0x78A8             LDRB     R0,[R5, #+2]
   \       0x38   0xF050 0x0040      ORRS     R0,R0,#0x40
   \       0x3C   0x70A8             STRB     R0,[R5, #+2]
    501          			break;
   \       0x3E   0xE005             B.N      ??ds3231_set_alarm1_4
    502          		case ds3231_PM :	//전달된 구조체의 알람 시간이 PM일 경우
    503          			alarm1_buff[2]|=0x60;	//BIT6 Logic High=12시간 표기, BIT5 Logic High=PM
   \                     ??ds3231_set_alarm1_2: (+1)
   \       0x40   0x78A8             LDRB     R0,[R5, #+2]
   \       0x42   0xF050 0x0060      ORRS     R0,R0,#0x60
   \       0x46   0x70A8             STRB     R0,[R5, #+2]
    504          			break;
   \       0x48   0xE000             B.N      ??ds3231_set_alarm1_4
    505          		case ds3231_24_hour :	//전달된 구조체의 알람 시간이 24시간 표기일 경우 (별도 설정 필요 X)
    506          			break;
   \                     ??ds3231_set_alarm1_1: (+1)
   \       0x4A   0xE7FF             B.N      ??ds3231_set_alarm1_4
    507          		default :
    508          			break;
    509          	}
    510          
    511          	/*
    512          	알람 기준을 요일로 할지 아니면 날짜로 할지를 설정
    513          	*/
    514          	switch(alarm1_data->day_date_select.day_or_date)
   \                     ??ds3231_set_alarm1_3: (+1)
   \                     ??ds3231_set_alarm1_4: (+1)
   \       0x4C   0x7920             LDRB     R0,[R4, #+4]
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD002             BEQ.N    ??ds3231_set_alarm1_5
   \       0x52   0x2801             CMP      R0,#+1
   \       0x54   0xD001             BEQ.N    ??ds3231_set_alarm1_6
   \       0x56   0xE005             B.N      ??ds3231_set_alarm1_7
    515          	{
    516          		case ds3231_date :	//날짜 설정, BIT6 - Low
    517          			break;
   \                     ??ds3231_set_alarm1_5: (+1)
   \       0x58   0xE004             B.N      ??ds3231_set_alarm1_8
    518          		case ds3231_day :
    519          			alarm1_buff[3]|=0x40;	//요일 설정, BIT6 - High
   \                     ??ds3231_set_alarm1_6: (+1)
   \       0x5A   0x78E8             LDRB     R0,[R5, #+3]
   \       0x5C   0xF050 0x0040      ORRS     R0,R0,#0x40
   \       0x60   0x70E8             STRB     R0,[R5, #+3]
    520          			break;
   \       0x62   0xE7FF             B.N      ??ds3231_set_alarm1_8
    521          		default :
    522          			break;
    523          	}
    524                  
    525          	HW_I2C_Write(I2C1, ds3231_addr, ds3231_alarm1_sec_addr, 1, &alarm1_buff[0]);
   \                     ??ds3231_set_alarm1_7: (+1)
   \                     ??ds3231_set_alarm1_8: (+1)
   \       0x64   0x....             LDR.N    R4,??DataTable12_5
   \       0x66   0xA801             ADD      R0,SP,#+4
   \       0x68   0x9000             STR      R0,[SP, #+0]
   \       0x6A   0x2301             MOVS     R3,#+1
   \       0x6C   0x2207             MOVS     R2,#+7
   \       0x6E   0x21D0             MOVS     R1,#+208
   \       0x70   0x0020             MOVS     R0,R4
   \       0x72   0x.... 0x....      BL       HW_I2C_Write
    526          	HW_I2C_Write(I2C1, ds3231_addr, ds3231_alarm1_min_addr, 1, &alarm1_buff[1]);
   \       0x76   0xF10D 0x0005      ADD      R0,SP,#+5
   \       0x7A   0x9000             STR      R0,[SP, #+0]
   \       0x7C   0x2301             MOVS     R3,#+1
   \       0x7E   0x2208             MOVS     R2,#+8
   \       0x80   0x21D0             MOVS     R1,#+208
   \       0x82   0x0020             MOVS     R0,R4
   \       0x84   0x.... 0x....      BL       HW_I2C_Write
    527          	HW_I2C_Write(I2C1, ds3231_addr, ds3231_alarm1_hour_addr, 1, &alarm1_buff[2]);
   \       0x88   0xF10D 0x0006      ADD      R0,SP,#+6
   \       0x8C   0x9000             STR      R0,[SP, #+0]
   \       0x8E   0x2301             MOVS     R3,#+1
   \       0x90   0x2209             MOVS     R2,#+9
   \       0x92   0x21D0             MOVS     R1,#+208
   \       0x94   0x0020             MOVS     R0,R4
   \       0x96   0x.... 0x....      BL       HW_I2C_Write
    528          	HW_I2C_Write(I2C1, ds3231_addr, ds3231_alarm1_day_date_addr, 1, &alarm1_buff[3]);
   \       0x9A   0xF10D 0x0007      ADD      R0,SP,#+7
   \       0x9E   0x9000             STR      R0,[SP, #+0]
   \       0xA0   0x2301             MOVS     R3,#+1
   \       0xA2   0x220A             MOVS     R2,#+10
   \       0xA4   0x21D0             MOVS     R1,#+208
   \       0xA6   0x0020             MOVS     R0,R4
   \       0xA8   0x.... 0x....      BL       HW_I2C_Write
    529                  
    530                  Alarm_flag = 0;
   \       0xAC   0x2000             MOVS     R0,#+0
   \       0xAE   0x....             LDR.N    R1,??DataTable12_24
   \       0xB0   0x6008             STR      R0,[R1, #+0]
    531          }
   \       0xB2   0xBD37             POP      {R0-R2,R4,R5,PC}
    532          

   \                                 In section .text, align 2, keep-with-next
    533          void ds3231_print_alarm1(ds3231_Alarm1 *current_alarm1)
    534          {
   \                     ds3231_print_alarm1: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
   \        0x4   0x0004             MOVS     R4,R0
    535                  char time[20] = "";
   \        0x6   0xA803             ADD      R0,SP,#+12
   \        0x8   0x2114             MOVS     R1,#+20
   \        0xA   0x.... 0x....      BL       __aeabi_memclr
    536                  char sprin_result[5] = "";
   \        0xE   0xA801             ADD      R0,SP,#+4
   \       0x10   0x2105             MOVS     R1,#+5
   \       0x12   0x.... 0x....      BL       __aeabi_memclr
    537                  
    538                  
    539                  strcat(time, "Alarm : ");
   \       0x16   0x....             LDR.N    R1,??DataTable12_25
   \       0x18   0xA803             ADD      R0,SP,#+12
   \       0x1A   0x.... 0x....      BL       strcat
    540            
    541          	switch (current_alarm1->day_date_select.day_or_date)	//0x0A - Alarm1 DAY/DATE Register
   \       0x1E   0x7920             LDRB     R0,[R4, #+4]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD002             BEQ.N    ??ds3231_print_alarm1_0
   \       0x24   0x2801             CMP      R0,#+1
   \       0x26   0xD015             BEQ.N    ??ds3231_print_alarm1_1
   \       0x28   0xE01B             B.N      ??ds3231_print_alarm1_2
    542          	{
    543          		case ds3231_date :	//BIT6 Low - Date
    544          			printf("Date : %d   ",(current_alarm1->day_date_select.value)&0x3F);
   \                     ??ds3231_print_alarm1_0: (+1)
   \       0x2A   0x7961             LDRB     R1,[R4, #+5]
   \       0x2C   0xF011 0x013F      ANDS     R1,R1,#0x3F
   \       0x30   0x....             LDR.N    R0,??DataTable12_26
   \       0x32   0x.... 0x....      BL       printf
    545                                  sprintf(sprin_result, "%d", (current_alarm1->day_date_select.value)&0x3F);
   \       0x36   0x7962             LDRB     R2,[R4, #+5]
   \       0x38   0xF012 0x023F      ANDS     R2,R2,#0x3F
   \       0x3C   0x....             ADR.N    R1,??DataTable11
   \       0x3E   0xA801             ADD      R0,SP,#+4
   \       0x40   0x.... 0x....      BL       sprintf
    546                                  strcat(time, sprin_result);
   \       0x44   0xA901             ADD      R1,SP,#+4
   \       0x46   0xA803             ADD      R0,SP,#+12
   \       0x48   0x.... 0x....      BL       strcat
    547                                  strcat(time, "/");
   \       0x4C   0x....             ADR.N    R1,??DataTable11_1
   \       0x4E   0x.... 0x....      BL       strcat
    548          			break;
   \       0x52   0xE006             B.N      ??ds3231_print_alarm1_3
    549          		case ds3231_day :	//BIT6 High - Day
    550          			printf("Day : %d   ",(current_alarm1->day_date_select.value)&0x0F);
   \                     ??ds3231_print_alarm1_1: (+1)
   \       0x54   0x7961             LDRB     R1,[R4, #+5]
   \       0x56   0xF011 0x010F      ANDS     R1,R1,#0xF
   \       0x5A   0x....             LDR.N    R0,??DataTable12_27
   \       0x5C   0x.... 0x....      BL       printf
    551          			break;
   \       0x60   0xE7FF             B.N      ??ds3231_print_alarm1_3
    552          		default :
    553          			break;
    554          	}
    555          
    556          	switch (current_alarm1->hour_select.am_pm_24)	//0x09 - Alarm1 Hour Register
   \                     ??ds3231_print_alarm1_2: (+1)
   \                     ??ds3231_print_alarm1_3: (+1)
   \       0x62   0x78A0             LDRB     R0,[R4, #+2]
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD003             BEQ.N    ??ds3231_print_alarm1_4
   \       0x68   0x2802             CMP      R0,#+2
   \       0x6A   0xD02B             BEQ.N    ??ds3231_print_alarm1_5
   \       0x6C   0xD315             BCC.N    ??ds3231_print_alarm1_6
   \       0x6E   0xE03A             B.N      ??ds3231_print_alarm1_7
    557          	{
    558          		case ds3231_AM :	//BIT6 - High, BIT5 - Low
    559          			printf("AM : %d   ",current_alarm1->hour_select.hour);
   \                     ??ds3231_print_alarm1_4: (+1)
   \       0x70   0x78E1             LDRB     R1,[R4, #+3]
   \       0x72   0x....             LDR.N    R0,??DataTable12_28
   \       0x74   0x.... 0x....      BL       printf
    560                                  strcat(time, "AM ");
   \       0x78   0x....             ADR.N    R1,??DataTable12
   \       0x7A   0xA803             ADD      R0,SP,#+12
   \       0x7C   0x.... 0x....      BL       strcat
    561                                  sprintf(sprin_result, "%d", current_alarm1->hour_select.hour);
   \       0x80   0x78E2             LDRB     R2,[R4, #+3]
   \       0x82   0x....             ADR.N    R1,??DataTable11
   \       0x84   0xA801             ADD      R0,SP,#+4
   \       0x86   0x.... 0x....      BL       sprintf
    562                                  strcat(time, sprin_result);
   \       0x8A   0xA901             ADD      R1,SP,#+4
   \       0x8C   0xA803             ADD      R0,SP,#+12
   \       0x8E   0x.... 0x....      BL       strcat
    563                                  strcat(time, ":");
   \       0x92   0x....             ADR.N    R1,??DataTable12_1
   \       0x94   0x.... 0x....      BL       strcat
    564          			break;
   \       0x98   0xE025             B.N      ??ds3231_print_alarm1_8
    565          		case ds3231_PM :	//BIT6 - High, BIT5 - High
    566          			printf("PM : %d   ",current_alarm1->hour_select.hour);
   \                     ??ds3231_print_alarm1_6: (+1)
   \       0x9A   0x78E1             LDRB     R1,[R4, #+3]
   \       0x9C   0x....             LDR.N    R0,??DataTable12_29
   \       0x9E   0x.... 0x....      BL       printf
    567                                  strcat(time, "PM ");
   \       0xA2   0x....             ADR.N    R1,??DataTable12_2
   \       0xA4   0xA803             ADD      R0,SP,#+12
   \       0xA6   0x.... 0x....      BL       strcat
    568                                  sprintf(sprin_result, "%d", current_alarm1->hour_select.hour);
   \       0xAA   0x78E2             LDRB     R2,[R4, #+3]
   \       0xAC   0x....             ADR.N    R1,??DataTable11
   \       0xAE   0xA801             ADD      R0,SP,#+4
   \       0xB0   0x.... 0x....      BL       sprintf
    569                                  strcat(time, sprin_result);
   \       0xB4   0xA901             ADD      R1,SP,#+4
   \       0xB6   0xA803             ADD      R0,SP,#+12
   \       0xB8   0x.... 0x....      BL       strcat
    570                                  strcat(time, ":");
   \       0xBC   0x....             ADR.N    R1,??DataTable12_1
   \       0xBE   0x.... 0x....      BL       strcat
    571          			break;
   \       0xC2   0xE010             B.N      ??ds3231_print_alarm1_8
    572          		case ds3231_24_hour :	//BIT6 - Low, BIT5 - 2x 시간일 때 High
    573          			printf("24 : %d   ",current_alarm1->hour_select.hour);
   \                     ??ds3231_print_alarm1_5: (+1)
   \       0xC4   0x78E1             LDRB     R1,[R4, #+3]
   \       0xC6   0x....             LDR.N    R0,??DataTable12_30
   \       0xC8   0x.... 0x....      BL       printf
    574                                  sprintf(sprin_result, "%d", current_alarm1->hour_select.hour);
   \       0xCC   0x78E2             LDRB     R2,[R4, #+3]
   \       0xCE   0x....             ADR.N    R1,??DataTable11
   \       0xD0   0xA801             ADD      R0,SP,#+4
   \       0xD2   0x.... 0x....      BL       sprintf
    575                                  strcat(time, sprin_result);
   \       0xD6   0xA901             ADD      R1,SP,#+4
   \       0xD8   0xA803             ADD      R0,SP,#+12
   \       0xDA   0x.... 0x....      BL       strcat
    576                                  strcat(time, ":");
   \       0xDE   0x....             ADR.N    R1,??DataTable12_1
   \       0xE0   0x.... 0x....      BL       strcat
    577          			break;
   \       0xE4   0xE7FF             B.N      ??ds3231_print_alarm1_8
    578          		default :
    579          			break;
    580          	}
    581          	printf("min : %d   sec : %d\r\n",current_alarm1->min,current_alarm1->sec);
   \                     ??ds3231_print_alarm1_7: (+1)
   \                     ??ds3231_print_alarm1_8: (+1)
   \       0xE6   0x7822             LDRB     R2,[R4, #+0]
   \       0xE8   0x7861             LDRB     R1,[R4, #+1]
   \       0xEA   0x....             LDR.N    R0,??DataTable12_31
   \       0xEC   0x.... 0x....      BL       printf
    582                  sprintf(sprin_result, "%d", current_alarm1->min);
   \       0xF0   0x....             ADR.N    R5,??DataTable11
   \       0xF2   0x7862             LDRB     R2,[R4, #+1]
   \       0xF4   0x0029             MOVS     R1,R5
   \       0xF6   0xA801             ADD      R0,SP,#+4
   \       0xF8   0x.... 0x....      BL       sprintf
    583                  strcat(time, sprin_result);
   \       0xFC   0xA901             ADD      R1,SP,#+4
   \       0xFE   0xA803             ADD      R0,SP,#+12
   \      0x100   0x.... 0x....      BL       strcat
    584                  strcat(time, ":");
   \      0x104   0x....             ADR.N    R1,??DataTable12_1
   \      0x106   0x.... 0x....      BL       strcat
    585                  sprintf(sprin_result, "%d", current_alarm1->sec);
   \      0x10A   0x7822             LDRB     R2,[R4, #+0]
   \      0x10C   0x0029             MOVS     R1,R5
   \      0x10E   0xA801             ADD      R0,SP,#+4
   \      0x110   0x.... 0x....      BL       sprintf
    586                  strcat(time, sprin_result);
   \      0x114   0xA901             ADD      R1,SP,#+4
   \      0x116   0xA803             ADD      R0,SP,#+12
   \      0x118   0x.... 0x....      BL       strcat
   \      0x11C   0x0001             MOVS     R1,R0
    587                  
    588                  printf("String : %s", time);
   \      0x11E   0x....             LDR.N    R0,??DataTable12_32
   \      0x120   0x.... 0x....      BL       printf
    589                  
    590                  LCD_ShowString(25, 135, time, BLACK, WHITE);
                                                 ^
Warning[Pe167]: argument of type "char *" is incompatible with parameter of
          type "u8 *"
   \      0x124   0xF64F 0x70FF      MOVW     R0,#+65535
   \      0x128   0x9000             STR      R0,[SP, #+0]
   \      0x12A   0x2300             MOVS     R3,#+0
   \      0x12C   0xAA03             ADD      R2,SP,#+12
   \      0x12E   0x2187             MOVS     R1,#+135
   \      0x130   0x2019             MOVS     R0,#+25
   \      0x132   0x.... 0x....      BL       LCD_ShowString
    591          }
   \      0x136   0xB009             ADD      SP,SP,#+36
   \      0x138   0xBD30             POP      {R4,R5,PC}

   \                                 In section .rodata, align 1
   \        0x0   0x00               DC8 ""
   \        0x1                      DS8 19

   \                                 In section .rodata, align 1
   \        0x0   0x00               DC8 ""
   \        0x1                      DS8 4
    592          

   \                                 In section .text, align 2, keep-with-next
    593          void ds3231_read_alarm1(ds3231_Alarm1 *current_alarm1)
    594          {
   \                     ds3231_read_alarm1: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    595          	uint8_t read_alarm1_buff[4];	//DS3231로부터 읽어 온 알람1 시간을 저장할 데이터 버퍼
    596                  
    597                  
    598          	HW_I2C_Read(I2C1, ds3231_addr,ds3231_alarm1_sec_addr, 1, &read_alarm1_buff[0]);
   \        0x4   0x....             LDR.N    R5,??DataTable12_5
   \        0x6   0xA801             ADD      R0,SP,#+4
   \        0x8   0x9000             STR      R0,[SP, #+0]
   \        0xA   0x2301             MOVS     R3,#+1
   \        0xC   0x2207             MOVS     R2,#+7
   \        0xE   0x21D0             MOVS     R1,#+208
   \       0x10   0x0028             MOVS     R0,R5
   \       0x12   0x.... 0x....      BL       HW_I2C_Read
    599          	HW_I2C_Read(I2C1, ds3231_addr,ds3231_alarm1_min_addr, 1, &read_alarm1_buff[1]);
   \       0x16   0xF10D 0x0005      ADD      R0,SP,#+5
   \       0x1A   0x9000             STR      R0,[SP, #+0]
   \       0x1C   0x2301             MOVS     R3,#+1
   \       0x1E   0x2208             MOVS     R2,#+8
   \       0x20   0x21D0             MOVS     R1,#+208
   \       0x22   0x0028             MOVS     R0,R5
   \       0x24   0x.... 0x....      BL       HW_I2C_Read
    600          	HW_I2C_Read(I2C1, ds3231_addr,ds3231_alarm1_hour_addr, 1, &read_alarm1_buff[2]);
   \       0x28   0xF10D 0x0006      ADD      R0,SP,#+6
   \       0x2C   0x9000             STR      R0,[SP, #+0]
   \       0x2E   0x2301             MOVS     R3,#+1
   \       0x30   0x2209             MOVS     R2,#+9
   \       0x32   0x21D0             MOVS     R1,#+208
   \       0x34   0x0028             MOVS     R0,R5
   \       0x36   0x.... 0x....      BL       HW_I2C_Read
    601          	HW_I2C_Read(I2C1, ds3231_addr,ds3231_alarm1_day_date_addr, 1, &read_alarm1_buff[3]);
   \       0x3A   0xF10D 0x0007      ADD      R0,SP,#+7
   \       0x3E   0x9000             STR      R0,[SP, #+0]
   \       0x40   0x2301             MOVS     R3,#+1
   \       0x42   0x220A             MOVS     R2,#+10
   \       0x44   0x21D0             MOVS     R1,#+208
   \       0x46   0x0028             MOVS     R0,R5
   \       0x48   0x.... 0x....      BL       HW_I2C_Read
    602              
    603          	/*
    604          	수신한 데이터를 10진수로 변환 후 전달받은 구조체에 입력
    605          	*/
    606          	current_alarm1->sec=bcdTodec(read_alarm1_buff[0]);
   \       0x4C   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \       0x50   0x.... 0x....      BL       bcdTodec
   \       0x54   0x7020             STRB     R0,[R4, #+0]
    607          	current_alarm1->min=bcdTodec(read_alarm1_buff[1]);
   \       0x56   0xAD01             ADD      R5,SP,#+4
   \       0x58   0x7868             LDRB     R0,[R5, #+1]
   \       0x5A   0x.... 0x....      BL       bcdTodec
   \       0x5E   0x7060             STRB     R0,[R4, #+1]
    608          
    609          	if((read_alarm1_buff[2]&0x40)!=0)	//12시간 표기를 사용할 경우
   \       0x60   0x78A8             LDRB     R0,[R5, #+2]
   \       0x62   0x0640             LSLS     R0,R0,#+25
   \       0x64   0xD514             BPL.N    ??ds3231_read_alarm1_0
    610          	{
    611          		if((read_alarm1_buff[2]&0x20)==0)	//알람 설정 시간이 AM일 경우
   \       0x66   0x78A8             LDRB     R0,[R5, #+2]
   \       0x68   0x0680             LSLS     R0,R0,#+26
   \       0x6A   0xD408             BMI.N    ??ds3231_read_alarm1_1
    612          		{
    613          			current_alarm1->hour_select.am_pm_24=ds3231_AM;
   \       0x6C   0x2000             MOVS     R0,#+0
   \       0x6E   0x70A0             STRB     R0,[R4, #+2]
    614          			current_alarm1->hour_select.hour=bcdTodec(read_alarm1_buff[2]&0x1F);
   \       0x70   0x78A8             LDRB     R0,[R5, #+2]
   \       0x72   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \       0x76   0x.... 0x....      BL       bcdTodec
   \       0x7A   0x70E0             STRB     R0,[R4, #+3]
   \       0x7C   0xE00C             B.N      ??ds3231_read_alarm1_2
    615          			//12시간 표기를 사용할 경우, 시간 레지스터에서 유효한 시간 데이터는 BIT 0 ~ BIT 4 까지
    616          		}
    617          		else	//알람 설정 시간이 PM일 경우
    618          		{
    619          			current_alarm1->hour_select.am_pm_24=ds3231_PM;
   \                     ??ds3231_read_alarm1_1: (+1)
   \       0x7E   0x2001             MOVS     R0,#+1
   \       0x80   0x70A0             STRB     R0,[R4, #+2]
    620          			current_alarm1->hour_select.hour=bcdTodec(read_alarm1_buff[2]&0x1F);
   \       0x82   0x78A8             LDRB     R0,[R5, #+2]
   \       0x84   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \       0x88   0x.... 0x....      BL       bcdTodec
   \       0x8C   0x70E0             STRB     R0,[R4, #+3]
   \       0x8E   0xE003             B.N      ??ds3231_read_alarm1_2
    621          		}
    622          	}
    623          	else	//24시간 표기
    624          	{
    625          		current_alarm1->hour_select.hour=bcdTodec(read_alarm1_buff[2]);	
   \                     ??ds3231_read_alarm1_0: (+1)
   \       0x90   0x78A8             LDRB     R0,[R5, #+2]
   \       0x92   0x.... 0x....      BL       bcdTodec
   \       0x96   0x70E0             STRB     R0,[R4, #+3]
    626          	}
    627          
    628          	if((read_alarm1_buff[3]&0x40)!=0)	//Day일 경우 (BIT 6 - High)
   \                     ??ds3231_read_alarm1_2: (+1)
   \       0x98   0x78E8             LDRB     R0,[R5, #+3]
   \       0x9A   0x0640             LSLS     R0,R0,#+25
   \       0x9C   0xD508             BPL.N    ??ds3231_read_alarm1_3
    629          	{
    630          		current_alarm1->day_date_select.day_or_date=ds3231_day;
   \       0x9E   0x2001             MOVS     R0,#+1
   \       0xA0   0x7120             STRB     R0,[R4, #+4]
    631          		current_alarm1->day_date_select.value=bcdTodec(read_alarm1_buff[3]&0x0F);
   \       0xA2   0x78E8             LDRB     R0,[R5, #+3]
   \       0xA4   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0xA8   0x.... 0x....      BL       bcdTodec
   \       0xAC   0x7160             STRB     R0,[R4, #+5]
   \       0xAE   0xE007             B.N      ??ds3231_read_alarm1_4
    632          		//Day 사용할 경우, 유효한 날짜 데이터는 BIT 0 ~ BIT 3까지
    633          	}
    634          	else	//Date일 경우 (BIT 6 - Low)
    635          	{
    636          		current_alarm1->day_date_select.day_or_date=ds3231_date;
   \                     ??ds3231_read_alarm1_3: (+1)
   \       0xB0   0x2000             MOVS     R0,#+0
   \       0xB2   0x7120             STRB     R0,[R4, #+4]
    637          		current_alarm1->day_date_select.value=bcdTodec(read_alarm1_buff[3]&0x3F);
   \       0xB4   0x78E8             LDRB     R0,[R5, #+3]
   \       0xB6   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \       0xBA   0x.... 0x....      BL       bcdTodec
   \       0xBE   0x7160             STRB     R0,[R4, #+5]
    638          		//Date 사용할 경우, 유효한 날짜 데이터는 BIT 0 ~ BIT 5까지
    639          	}
    640          
    641          	ds3231_print_alarm1(current_alarm1);	//읽어 온 알람1 데이터를 출력하기 위한 함수 호출
   \                     ??ds3231_read_alarm1_4: (+1)
   \       0xC0   0x0020             MOVS     R0,R4
   \       0xC2   0x.... 0x....      BL       ds3231_print_alarm1
    642          }
   \       0xC6   0xBD37             POP      {R0-R2,R4,R5,PC}
    643          

   \                                 In section .text, align 2, keep-with-next
    644          void Delay_little(void) {
    645             int i;
    646          
    647             for (i = 0; i < 2000000; i++) {}
   \                     Delay_little: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0xE000             B.N      ??Delay_little_0
   \                     ??Delay_little_1: (+1)
   \        0x4   0x1C40             ADDS     R0,R0,#+1
   \                     ??Delay_little_0: (+1)
   \        0x6   0x....             LDR.N    R1,??DataTable12_33
   \        0x8   0x4288             CMP      R0,R1
   \        0xA   0xDBFB             BLT.N    ??Delay_little_1
    648          }
   \        0xC   0x4770             BX       LR
    649          

   \                                 In section .text, align 2, keep-with-next
    650          void RCC_Configure_ds3231(void)
    651          {
   \                     RCC_Configure_ds3231: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    652            /* 1-1. TIM Clock Enable */
    653            //RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
    654            /* 1-2. enable for PB7 */
    655            RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);     // RCC GPIO B
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0x2008             MOVS     R0,#+8
   \        0x6   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    656            RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);    // interrupt
   \        0xA   0x2101             MOVS     R1,#+1
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    657            /* 2. Enable for button -> use PD11 for s1 user */
    658            RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD,ENABLE);     // RCC GPIO D
   \       0x12   0x2101             MOVS     R1,#+1
   \       0x14   0x2020             MOVS     R0,#+32
   \       0x16   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    659          }
   \       0x1A   0xBD01             POP      {R0,PC}
    660          

   \                                 In section .text, align 2, keep-with-next
    661          void GPIO_Configure_ds3231(void)
    662          {
   \                     GPIO_Configure_ds3231: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    663             GPIO_InitTypeDef GPIO_InitStructure;
    664             
    665            /* init for button PD11(s1 user) */
    666            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
   \        0x2   0xF44F 0x6000      MOV      R0,#+2048
   \        0x6   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    667            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
   \        0xA   0x2048             MOVS     R0,#+72
   \        0xC   0xF88D 0x0003      STRB     R0,[SP, #+3]
    668            GPIO_Init(GPIOD, &GPIO_InitStructure); 
   \       0x10   0x4669             MOV      R1,SP
   \       0x12   0x....             LDR.N    R0,??DataTable12_34
   \       0x14   0x.... 0x....      BL       GPIO_Init
    669            
    670            /* Configure the PB7 or BUZZER pin */
    671            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;
   \       0x18   0x2080             MOVS     R0,#+128
   \       0x1A   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    672            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \       0x1E   0x2010             MOVS     R0,#+16
   \       0x20   0xF88D 0x0003      STRB     R0,[SP, #+3]
    673            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \       0x24   0x2003             MOVS     R0,#+3
   \       0x26   0xF88D 0x0002      STRB     R0,[SP, #+2]
    674            GPIO_Init(GPIOB, &GPIO_InitStructure);
   \       0x2A   0x4669             MOV      R1,SP
   \       0x2C   0x....             LDR.N    R0,??DataTable12_35
   \       0x2E   0x.... 0x....      BL       GPIO_Init
    675          }
   \       0x32   0xBD01             POP      {R0,PC}
    676          

   \                                 In section .text, align 2, keep-with-next
    677          void DS3231_Alarm_Init() {
   \                     DS3231_Alarm_Init: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    678            SystemInit();
   \        0x2   0x.... 0x....      BL       SystemInit
    679            RCC_Configure();
                   ^
Warning[Pe223]: function "RCC_Configure" declared implicitly
   \        0x6   0x.... 0x....      BL       RCC_Configure
    680            GPIO_Configure();
                   ^
Warning[Pe223]: function "GPIO_Configure" declared implicitly

    (void)(temp);
           ^
"C:\embedded\project\user\DS3231_BUZZER.c",44  Warning[Go029]: Variable "temp"
          is used uninitialized at this location in the sourcecode.
   \        0xA   0x.... 0x....      BL       GPIO_Configure
    681          
    682            I2C_Configure();
   \        0xE   0x.... 0x....      BL       I2C_Configure
    683            LCD_Init();
   \       0x12   0x.... 0x....      BL       LCD_Init
    684            LCD_Clear(WHITE);
   \       0x16   0xF64F 0x70FF      MOVW     R0,#+65535
   \       0x1A   0x.... 0x....      BL       LCD_Clear
    685          }
   \       0x1E   0xBD01             POP      {R0,PC}
    686          

   \                                 In section .text, align 2, keep-with-next
    687          void alarm_check(ds3231_time *current_time, ds3231_Alarm1 *alarm1_data) {
   \                     alarm_check: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    688            if (current_time->date >= alarm1_data->day_date_select.value) {
   \        0x2   0x7942             LDRB     R2,[R0, #+5]
   \        0x4   0x794B             LDRB     R3,[R1, #+5]
   \        0x6   0x429A             CMP      R2,R3
   \        0x8   0xD330             BCC.N    ??alarm_check_0
    689              if (current_time->hour_select.am_pm_24 == alarm1_data->hour_select.am_pm_24) {
   \        0xA   0x7882             LDRB     R2,[R0, #+2]
   \        0xC   0x788B             LDRB     R3,[R1, #+2]
   \        0xE   0x429A             CMP      R2,R3
   \       0x10   0xD12C             BNE.N    ??alarm_check_0
    690                if (current_time->hour_select.hour >= alarm1_data->hour_select.hour) {
   \       0x12   0x78C2             LDRB     R2,[R0, #+3]
   \       0x14   0x78CB             LDRB     R3,[R1, #+3]
   \       0x16   0x429A             CMP      R2,R3
   \       0x18   0xD328             BCC.N    ??alarm_check_0
    691                  if (current_time->min >= alarm1_data->min) {
   \       0x1A   0x7842             LDRB     R2,[R0, #+1]
   \       0x1C   0x784B             LDRB     R3,[R1, #+1]
   \       0x1E   0x429A             CMP      R2,R3
   \       0x20   0xD324             BCC.N    ??alarm_check_0
    692                    if (current_time->sec >= alarm1_data->sec) {
   \       0x22   0x7800             LDRB     R0,[R0, #+0]
   \       0x24   0x7809             LDRB     R1,[R1, #+0]
   \       0x26   0x4288             CMP      R0,R1
   \       0x28   0xD320             BCC.N    ??alarm_check_0
    693                      if (Alarm_flag == 0) { // 알람 작동시
   \       0x2A   0x....             LDR.N    R4,??DataTable12_24
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD10B             BNE.N    ??alarm_check_1
    694                        GPIO_SetBits(GPIOB, GPIO_Pin_7); // 부저 작동
   \       0x32   0x2180             MOVS     R1,#+128
   \       0x34   0x....             LDR.N    R0,??DataTable12_35
   \       0x36   0x.... 0x....      BL       GPIO_SetBits
    695                        
    696                        Alarm_flag = 1;
   \       0x3A   0x2001             MOVS     R0,#+1
   \       0x3C   0x6020             STR      R0,[R4, #+0]
    697                        Alarm_ONOFF = 1;
   \       0x3E   0x2001             MOVS     R0,#+1
   \       0x40   0x....             LDR.N    R1,??DataTable12_36
   \       0x42   0x6008             STR      R0,[R1, #+0]
    698                        printf("Alarm Active");
   \       0x44   0x....             LDR.N    R0,??DataTable12_37
   \       0x46   0x.... 0x....      BL       printf
    699                      }
    700                      
    701                      if (!GPIO_ReadInputDataBit(GPIOD, GPIO_Pin_11)) { // S1 버튼 누를시
   \                     ??alarm_check_1: (+1)
   \       0x4A   0xF44F 0x6100      MOV      R1,#+2048
   \       0x4E   0x....             LDR.N    R0,??DataTable12_34
   \       0x50   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD109             BNE.N    ??alarm_check_0
    702                        GPIO_ResetBits(GPIOB, GPIO_Pin_7); // 부저 종료
   \       0x58   0x2180             MOVS     R1,#+128
   \       0x5A   0x....             LDR.N    R0,??DataTable12_35
   \       0x5C   0x.... 0x....      BL       GPIO_ResetBits
    703                        printf("Alarm END");
   \       0x60   0x....             LDR.N    R0,??DataTable12_38
   \       0x62   0x.... 0x....      BL       printf
    704                        
    705                        Alarm_ONOFF = 0;
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0x....             LDR.N    R1,??DataTable12_36
   \       0x6A   0x6008             STR      R0,[R1, #+0]
    706                      }
    707                    }
    708                  }
    709                }
    710              }
    711            }
    712          }
   \                     ??alarm_check_0: (+1)
   \       0x6C   0xBD10             POP      {R4,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0x25 0x64          DC8      0x25, 0x64, 0x00, 0x00

   \              0x00 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \        0x0   0x2D 0x00          DC8      "-",0x0,0x0    

   \              0x00 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \        0x0   0x20 0x00          DC8      " ",0x0,0x0    

   \              0x00 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0x3A 0x00          DC8      ":",0x0,0x0    

   \              0x00 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \        0x0   0x25 0x64          DC8      0x25, 0x64, 0x00, 0x00

   \              0x00 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \        0x0   0x2F 0x00          DC8      "/",0x0,0x0    

   \              0x00 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \        0x0   0x41 0x4D          DC8      "AM "          

   \              0x20 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \        0x0   0x3A 0x00          DC8      ":",0x0,0x0    

   \              0x00 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \        0x0   0x50 0x4D          DC8      "PM "          

   \              0x20 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \        0x0   0x4001'0004        DC32     0x40010004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \        0x0   0x4001'0C04        DC32     0x40010c04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \        0x0   0x4000'5400        DC32     0x40005400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \        0x0   0x4000'5404        DC32     0x40005404

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_7:
   \        0x0   0x4000'541C        DC32     0x4000541c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_8:
   \        0x0   0x4000'5420        DC32     0x40005420

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_9:
   \        0x0   0x1002'0400        DC32     0x10020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_10:
   \        0x0   0x0003'0001        DC32     0x30001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_11:
   \        0x0   0x0007'0082        DC32     0x70082

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_12:
   \        0x0   0x0007'0084        DC32     0x70084

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_13:
   \        0x0   0x1000'0002        DC32     0x10000002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_14:
   \        0x0   0x0003'0002        DC32     0x30002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_15:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_16:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_17:
   \        0x0   0x....'....        DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_18:
   \        0x0   0x....'....        DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_19:
   \        0x0   0x....'....        DC32     ?_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_20:
   \        0x0   0x....'....        DC32     ?_9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_21:
   \        0x0   0x....'....        DC32     ?_10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_22:
   \        0x0   0x....'....        DC32     ?_11

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_23:
   \        0x0   0x....'....        DC32     ?_12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_24:
   \        0x0   0x....'....        DC32     Alarm_flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_25:
   \        0x0   0x....'....        DC32     ?_13

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_26:
   \        0x0   0x....'....        DC32     ?_14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_27:
   \        0x0   0x....'....        DC32     ?_16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_28:
   \        0x0   0x....'....        DC32     ?_17

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_29:
   \        0x0   0x....'....        DC32     ?_19

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_30:
   \        0x0   0x....'....        DC32     ?_21

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_31:
   \        0x0   0x....'....        DC32     ?_22

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_32:
   \        0x0   0x....'....        DC32     ?_23

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_33:
   \        0x0   0x001E'8480        DC32     0x1e8480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_34:
   \        0x0   0x4001'1400        DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_35:
   \        0x0   0x4001'0C00        DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_36:
   \        0x0   0x....'....        DC32     Alarm_ONOFF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_37:
   \        0x0   0x....'....        DC32     ?_24

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_38:
   \        0x0   0x....'....        DC32     ?_25

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x25 0x64          DC8 "%d-%d-%d"

   \              0x2D 0x25    

   \              0x64 0x2D    

   \              0x25 0x64    

   \              0x00
   \        0x9                      DS8 3

   \                                 In section .rodata, align 4
   \        0x0   0x25 0x64          DC8 "%d"

   \              0x00
   \        0x3                      DS8 1

   \                                 In section .rodata, align 2
   \        0x0   0x2D 0x00          DC8 "-"

   \                                 In section .rodata, align 2
   \        0x0   0x20 0x00          DC8 " "

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x41 0x4D          DC8 "AM : %d:"

   \              0x20 0x3A    

   \              0x20 0x25    

   \              0x64 0x3A    

   \              0x00
   \        0x9                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_5:
   \        0x0   0x41 0x4D          DC8 "AM : "

   \              0x20 0x3A    

   \              0x20 0x00
   \        0x6                      DS8 2

   \                                 In section .rodata, align 2
   \        0x0   0x3A 0x00          DC8 ":"

   \                                 In section .rodata, align 4
   \                     ?_7:
   \        0x0   0x50 0x4D          DC8 "PM : %d:"

   \              0x20 0x3A    

   \              0x20 0x25    

   \              0x64 0x3A    

   \              0x00
   \        0x9                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_8:
   \        0x0   0x50 0x4D          DC8 "PM : "

   \              0x20 0x3A    

   \              0x20 0x00
   \        0x6                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_9:
   \        0x0   0x32 0x34          DC8 "24 : %d:"

   \              0x20 0x3A    

   \              0x20 0x25    

   \              0x64 0x3A    

   \              0x00
   \        0x9                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_10:
   \        0x0   0x32 0x34          DC8 "24 : "

   \              0x20 0x3A    

   \              0x20 0x00
   \        0x6                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_11:
   \        0x0   0x25 0x64          DC8 "%d:%d\015\012"

   \              0x3A 0x25    

   \              0x64 0x0D    

   \              0x0A 0x00

   \                                 In section .rodata, align 4
   \                     ?_12:
   \        0x0   0x53 0x74          DC8 "String : %s\012"

   \              0x72 0x69    

   \              0x6E 0x67    

   \              0x20 0x3A    

   \              0x20 0x25    

   \              0x73 0x0A    

   \              0x00
   \        0xD                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_13:
   \        0x0   0x41 0x6C          DC8 "Alarm : "

   \              0x61 0x72    

   \              0x6D 0x20    

   \              0x3A 0x20    

   \              0x00
   \        0x9                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_14:
   \        0x0   0x44 0x61          DC8 "Date : %d   "

   \              0x74 0x65    

   \              0x20 0x3A    

   \              0x20 0x25    

   \              0x64 0x20    

   \              0x20 0x20    

   \              0x00
   \        0xD                      DS8 3

   \                                 In section .rodata, align 2
   \        0x0   0x2F 0x00          DC8 "/"

   \                                 In section .rodata, align 4
   \                     ?_16:
   \        0x0   0x44 0x61          DC8 "Day : %d   "

   \              0x79 0x20    

   \              0x3A 0x20    

   \              0x25 0x64    

   \              0x20 0x20    

   \              0x20 0x00

   \                                 In section .rodata, align 4
   \                     ?_17:
   \        0x0   0x41 0x4D          DC8 "AM : %d   "

   \              0x20 0x3A    

   \              0x20 0x25    

   \              0x64 0x20    

   \              0x20 0x20    

   \              0x00
   \        0xB                      DS8 1

   \                                 In section .rodata, align 4
   \        0x0   0x41 0x4D          DC8 "AM "

   \              0x20 0x00

   \                                 In section .rodata, align 4
   \                     ?_19:
   \        0x0   0x50 0x4D          DC8 "PM : %d   "

   \              0x20 0x3A    

   \              0x20 0x25    

   \              0x64 0x20    

   \              0x20 0x20    

   \              0x00
   \        0xB                      DS8 1

   \                                 In section .rodata, align 4
   \        0x0   0x50 0x4D          DC8 "PM "

   \              0x20 0x00

   \                                 In section .rodata, align 4
   \                     ?_21:
   \        0x0   0x32 0x34          DC8 "24 : %d   "

   \              0x20 0x3A    

   \              0x20 0x25    

   \              0x64 0x20    

   \              0x20 0x20    

   \              0x00
   \        0xB                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_22:
   \        0x0   0x6D 0x69          DC8 "min : %d   sec : %d\015\012"

   \              0x6E 0x20    

   \              0x3A 0x20    

   \              0x25 0x64    

   \              0x20 0x20    

   \              0x20 0x73    

   \              0x65 0x63    

   \              0x20 0x3A    

   \              0x20 0x25    

   \              0x64 0x0D    

   \              0x0A 0x00
   \       0x16                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_23:
   \        0x0   0x53 0x74          DC8 "String : %s"

   \              0x72 0x69    

   \              0x6E 0x67    

   \              0x20 0x3A    

   \              0x20 0x25    

   \              0x73 0x00

   \                                 In section .rodata, align 4
   \                     ?_24:
   \        0x0   0x41 0x6C          DC8 "Alarm Active"

   \              0x61 0x72    

   \              0x6D 0x20    

   \              0x41 0x63    

   \              0x74 0x69    

   \              0x76 0x65    

   \              0x00
   \        0xD                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_25:
   \        0x0   0x41 0x6C          DC8 "Alarm END"

   \              0x61 0x72    

   \              0x6D 0x20    

   \              0x45 0x4E    

   \              0x44 0x00
   \        0xA                      DS8 2

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   DS3231_Alarm_Init
         8   -> GPIO_Configure
         8   -> I2C_Configure
         8   -> LCD_Clear
         8   -> LCD_Init
         8   -> RCC_Configure
         8   -> SystemInit
       0   Delay_little
       8   GPIO_Configure_ds3231
         8   -> GPIO_Init
      32   HW_I2C_Read
        32   -> I2C_AcknowledgeConfig
        32   -> I2C_CheckEvent
        32   -> I2C_ClearFlag
        32   -> I2C_Cmd
        32   -> I2C_GenerateSTART
        32   -> I2C_GenerateSTOP
        32   -> I2C_GetFlagStatus
        32   -> I2C_GetLastEvent
        32   -> I2C_ReceiveData
        32   -> I2C_Send7bitAddress
        32   -> I2C_SendData
      32   HW_I2C_Write
        32   -> I2C_CheckEvent
        32   -> I2C_ClearFlag
        32   -> I2C_GenerateSTART
        32   -> I2C_GenerateSTOP
        32   -> I2C_GetLastEvent
        32   -> I2C_Send7bitAddress
        32   -> I2C_SendData
       8   I2C_Configure
         8   -> I2C_Cmd
         8   -> I2C_DeInit
         8   -> RCC_APB1PeriphClockCmd
         8   -> RCC_APB2PeriphClockCmd
       8   RCC_Configure_ds3231
         8   -> RCC_APB2PeriphClockCmd
       8   alarm_check
         8   -> GPIO_ReadInputDataBit
         8   -> GPIO_ResetBits
         8   -> GPIO_SetBits
         8   -> printf
       0   bcdTodec
       0   decTobcd
      48   ds3231_print_alarm1
        48   -> LCD_ShowString
        48   -> __aeabi_memclr
        48   -> printf
        48   -> sprintf
        48   -> strcat
      48   ds3231_print_time
        48   -> LCD_ShowString
        48   -> __aeabi_memclr
        48   -> printf
        48   -> sprintf
        48   -> strcat
      24   ds3231_read_alarm1
        24   -> HW_I2C_Read
        24   -> bcdTodec
        24   -> ds3231_print_alarm1
      24   ds3231_read_time
        24   -> HW_I2C_Read
        24   -> bcdTodec
        24   -> ds3231_print_time
      24   ds3231_set_alarm1
        24   -> HW_I2C_Write
        24   -> decTobcd
      24   ds3231_write_time
        24   -> HW_I2C_Write
        24   -> decTobcd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_10
       4  ??DataTable12_11
       4  ??DataTable12_12
       4  ??DataTable12_13
       4  ??DataTable12_14
       4  ??DataTable12_15
       4  ??DataTable12_16
       4  ??DataTable12_17
       4  ??DataTable12_18
       4  ??DataTable12_19
       4  ??DataTable12_2
       4  ??DataTable12_20
       4  ??DataTable12_21
       4  ??DataTable12_22
       4  ??DataTable12_23
       4  ??DataTable12_24
       4  ??DataTable12_25
       4  ??DataTable12_26
       4  ??DataTable12_27
       4  ??DataTable12_28
       4  ??DataTable12_29
       4  ??DataTable12_3
       4  ??DataTable12_30
       4  ??DataTable12_31
       4  ??DataTable12_32
       4  ??DataTable12_33
       4  ??DataTable12_34
       4  ??DataTable12_35
       4  ??DataTable12_36
       4  ??DataTable12_37
       4  ??DataTable12_38
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable7
      12  ?_0
       4  ?_1
       8  ?_10
       8  ?_11
      16  ?_12
      12  ?_13
      16  ?_14
       2  ?_15
      12  ?_16
      12  ?_17
       4  ?_18
      12  ?_19
       2  ?_2
       4  ?_20
      12  ?_21
      24  ?_22
      12  ?_23
      16  ?_24
      12  ?_25
      20  ?_26
       5  ?_27
      20  ?_28
       5  ?_29
       2  ?_3
      12  ?_4
       8  ?_5
       2  ?_6
      12  ?_7
       8  ?_8
      12  ?_9
       4  Alarm_ONOFF
       4  Alarm_flag
      32  DS3231_Alarm_Init
      14  Delay_little
      52  GPIO_Configure_ds3231
     684  HW_I2C_Read
     312  HW_I2C_Write
     104  I2C_Configure
      28  RCC_Configure_ds3231
     110  alarm_check
      28  bcdTodec
      30  decTobcd
     314  ds3231_print_alarm1
     366  ds3231_print_time
     200  ds3231_read_alarm1
     220  ds3231_read_time
     180  ds3231_set_alarm1
     228  ds3231_write_time

 
     4 bytes in section .bss
     4 bytes in section .data
   306 bytes in section .rodata
 3'082 bytes in section .text
 
 3'082 bytes of CODE  memory
   306 bytes of CONST memory
     8 bytes of DATA  memory

Errors: none
Warnings: 6
